{
  "version": 3,
  "sources": ["../src/index.js"],
  "sourcesContent": ["'use strict';\nconst _createHmac = crypto.createHmac || (await import('node:crypto').then(m => m.createHmac));\nconst _createHash = crypto.createHash || (await import('node:crypto').then(m => m.createHash));\n\nif (typeof _createHmac === 'undefined' && typeof _createHash === 'undefined') {\n  console.error(\n    'FemtoS3 Module: Crypto functions are not available, please report the issue with necessary description: https://github.com/sentienhq/femtoS3.js/issues',\n  );\n}\n\n// Constants\nconst AWS_ALGORITHM = 'AWS4-HMAC-SHA256';\nconst AWS_REQUEST_TYPE = 'aws4_request';\nconst S3_SERVICE = 's3';\nconst LIST_TYPE = '2';\nconst UNSIGNED_PAYLOAD = 'UNSIGNED-PAYLOAD';\nconst DEFAULT_STREAM_CONTENT_TYPE = 'application/octet-stream';\nconst XML_CONTENT_TYPE = 'application/xml';\nconst JSON_CONTENT_TYPE = 'application/json';\n// List of keys that might contain sensitive information\nconst SENSITIVE_KEYS_REDACTED = ['accessKeyId', 'secretAccessKey', 'sessionToken', 'password'];\n\n// Headers\nconst HEADER_AMZ_CONTENT_SHA256 = 'x-amz-content-sha256';\nconst HEADER_AMZ_DATE = 'x-amz-date';\nconst HEADER_HOST = 'host';\nconst HEADER_AUTHORIZATION = 'Authorization';\nconst HEADER_CONTENT_TYPE = 'Content-Type';\nconst HEADER_CONTENT_LENGTH = 'Content-Length';\nconst HEADER_ETAG = 'etag';\nconst HEADER_LAST_MODIFIED = 'last-modified';\n\n// Error messages\nconst ERROR_PREFIX = 'FemtoS3 Module: ';\nconst ERROR_ACCESS_KEY_REQUIRED = `${ERROR_PREFIX}accessKeyId must be a non-empty string`;\nconst ERROR_SECRET_KEY_REQUIRED = `${ERROR_PREFIX}secretAccessKey must be a non-empty string`;\nconst ERROR_ENDPOINT_REQUIRED = `${ERROR_PREFIX}endpoint must be a non-empty string`;\nconst ERROR_BUCKET_NAME_REQUIRED = `${ERROR_PREFIX}bucketName must be a non-empty string`;\nconst ERROR_KEY_REQUIRED = `${ERROR_PREFIX}key must be a non-empty string`;\nconst ERROR_UPLOAD_ID_REQUIRED = `${ERROR_PREFIX}uploadId must be a non-empty string`;\nconst ERROR_PARTS_REQUIRED = `${ERROR_PREFIX}parts must be a non-empty array`;\nconst ERROR_INVALID_PART = `${ERROR_PREFIX}Each part must have a PartNumber (number) and ETag (string)`;\nconst ERROR_DATA_BUFFER_REQUIRED = `${ERROR_PREFIX}data must be a Buffer or string`;\nconst ERROR_PATH_REQUIRED = `${ERROR_PREFIX}path must be a string`;\nconst ERROR_PREFIX_TYPE = `${ERROR_PREFIX}prefix must be a string`;\nconst ERROR_MAX_KEYS_TYPE = `${ERROR_PREFIX}maxKeys must be a positive integer`;\n\nconst expectArray = {\n  contents: true,\n};\n\n/**\n * S3 class for interacting with S3-compatible object storage services.\n * This class provides methods for common S3 operations such as uploading, downloading,\n * and deleting objects, as well as multipart uploads.\n *\n * @class\n * @example\n * const s3 = new S3({\n *   accessKeyId: 'your-access-key',\n *   secretAccessKey: 'your-secret-key',\n *   endpoint: 'https://your-s3-endpoint.com',\n *   bucketName: 'your-bucket-name',\n *   region: 'us-east-1'\n * });\n *\n * // Upload a file\n * await s3.put('example.txt', 'Hello, World!');\n *\n * // Download a file\n * const content = await s3.get('example.txt');\n *\n * // Delete a file\n * await s3.delete('example.txt');\n */\nclass S3 {\n  /**\n   * Creates an instance of the S3 class.\n   *\n   * @constructor\n   * @param {Object} config - Configuration options for the S3 instance.\n   * @param {string} config.accessKeyId - The access key ID for authentication.\n   * @param {string} config.secretAccessKey - The secret access key for authentication.\n   * @param {string} config.endpoint - The endpoint URL of the S3-compatible service.\n   * @param {string} [config.bucketName=''] - The name of the bucket to operate on.\n   * @param {string} [config.region='auto'] - The region of the S3 service.\n   * @param {number} [config.maxRequestSizeInBytes=5242880] - The maximum size of a single request in bytes (default is 5MB).\n   * @param {number} [config.requestAbortTimeout=undefined] - The timeout in milliseconds after which a request should be aborted.\n   * @param {Object} [config.logger=null] - A logger object with methods like info, warn, error.\n   * @throws {TypeError} Will throw an error if required parameters are missing or of incorrect type.\n   */\n  constructor({\n    accessKeyId,\n    secretAccessKey,\n    endpoint,\n    bucketName,\n    region = 'auto',\n    maxRequestSizeInBytes = 5 * 1024 * 1024,\n    requestAbortTimeout = undefined,\n    logger = null,\n  }) {\n    this._validateConstructorParams(accessKeyId, secretAccessKey, endpoint, bucketName);\n    this.accessKeyId = accessKeyId;\n    this.secretAccessKey = secretAccessKey;\n    this.endpoint = endpoint;\n    this.bucketName = bucketName;\n    this.region = region;\n    this.maxRequestSizeInBytes = maxRequestSizeInBytes;\n    this.requestAbortTimeout = requestAbortTimeout;\n    this.logger = logger;\n  }\n\n  _validateConstructorParams(accessKeyId, secretAccessKey, endpoint, bucketName) {\n    if (typeof accessKeyId !== 'string' || accessKeyId.trim().length === 0)\n      throw new TypeError(ERROR_ACCESS_KEY_REQUIRED);\n    if (typeof secretAccessKey !== 'string' || secretAccessKey.trim().length === 0)\n      throw new TypeError(ERROR_SECRET_KEY_REQUIRED);\n    if (typeof endpoint !== 'string' || endpoint.trim().length === 0) throw new TypeError(ERROR_ENDPOINT_REQUIRED);\n    if (typeof bucketName !== 'string' || bucketName.trim().length === 0)\n      throw new TypeError(ERROR_BUCKET_NAME_REQUIRED);\n  }\n\n  /**\n   * Internal method to log messages with sanitized sensitive information.\n   * @param {string} level - The log level (e.g., 'info', 'warn', 'error').\n   * @param {string} message - The message to log.\n   * @param {Object} [additionalData={}] - Additional data to include in the log.\n   * @private\n   */\n  _log(level, message, additionalData = {}) {\n    if (this.logger && typeof this.logger[level] === 'function') {\n      // Function to recursively sanitize an object\n      const sanitize = obj => {\n        if (typeof obj !== 'object' || obj === null) {\n          return obj;\n        }\n        return Object.keys(obj).reduce(\n          (acc, key) => {\n            if (SENSITIVE_KEYS_REDACTED.includes(key.toLowerCase())) {\n              acc[key] = '[REDACTED]';\n            } else if (typeof obj[key] === 'object' && obj[key] !== null) {\n              acc[key] = sanitize(obj[key]);\n            } else {\n              acc[key] = obj[key];\n            }\n            return acc;\n          },\n          Array.isArray(obj) ? [] : {},\n        );\n      };\n\n      // Sanitize the additional data\n      const sanitizedData = sanitize(additionalData);\n      // Prepare the log entry\n      const logEntry = {\n        timestamp: new Date().toISOString(),\n        level,\n        message,\n        ...sanitizedData,\n        // Include some general context, but sanitize sensitive parts\n        context: sanitize({\n          bucketName: this.bucketName,\n          region: this.region,\n          endpoint: this.endpoint,\n          // Only include the first few characters of the access key, if it exists\n          accessKeyId: this.accessKeyId ? `${this.accessKeyId.substring(0, 4)}...` : undefined,\n        }),\n      };\n\n      // Log the sanitized entry\n      this.logger[level](logEntry);\n    }\n  }\n\n  getBucketName = () => this.bucketName;\n  setBucketName = bucketName => {\n    this.bucketName = bucketName;\n  };\n  getRegion = () => this.region;\n  setRegion = region => {\n    this.region = region;\n  };\n  getEndpoint = () => this.endpoint;\n  setEndpoint = endpoint => {\n    this.endpoint = endpoint;\n  };\n  getMaxRequestSizeInBytes = () => this.maxRequestSizeInBytes;\n  setMaxRequestSizeInBytes = maxRequestSizeInBytes => {\n    this.maxRequestSizeInBytes = maxRequestSizeInBytes;\n  };\n\n  getProps = () => ({\n    accessKeyId: this.accessKeyId,\n    secretAccessKey: this.secretAccessKey,\n    region: this.region,\n    bucket: this.bucketName,\n    endpoint: this.endpoint,\n    maxRequestSizeInBytes: this.maxRequestSizeInBytes,\n    requestAbortTimeout: this.requestAbortTimeout,\n    logger: this.logger,\n  });\n  setProps = props => {\n    this._validateConstructorParams(props.accessKeyId, props.secretAccessKey, props.endpoint);\n    this.accessKeyId = props.accessKeyId;\n    this.secretAccessKey = props.secretAccessKey;\n    this.region = props.region;\n    this.bucketName = props.bucket;\n    this.endpoint = props.endpoint;\n    this.maxRequestSizeInBytes = props.maxRequestSizeInBytes;\n    this.requestAbortTimeout = props.requestAbortTimeout;\n    this.logger = props.logger;\n  };\n\n  /**\n   * Get the content length of an object.\n   * @param {string} key - The key of the object.\n   * @returns {Promise<number>} The content length of the object in bytes.\n   * @throws {TypeError} If the key is not a non-empty string.\n   */\n  async getContentLength(key) {\n    if (typeof key !== 'string' || key.trim().length === 0) {\n      this._log('error', ERROR_KEY_REQUIRED);\n      throw new TypeError(ERROR_KEY_REQUIRED);\n    }\n    const headers = { [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD };\n    const { url, headers: signedHeaders } = await this._sign('HEAD', key, {}, headers, '');\n    const res = await this._sendRequest(url, 'HEAD', signedHeaders);\n    const contentLength = res.headers.get(HEADER_CONTENT_LENGTH);\n    return contentLength ? parseInt(contentLength, 10) : 0;\n  }\n\n  /**\n   * Check if a file exists in the bucket.\n   * @param {string} key - The key of the object.\n   * @returns {Promise<boolean>} True if the file exists, false otherwise.\n   * @throws {TypeError} If the key is not a non-empty string.\n   */\n  async fileExists(key) {\n    if (typeof key !== 'string' || key.trim().length === 0) {\n      this._log('error', ERROR_KEY_REQUIRED);\n      throw new TypeError(ERROR_KEY_REQUIRED);\n    }\n    const headers = { [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD };\n    const { url, headers: signedHeaders } = await this._sign('HEAD', key, {}, headers, '');\n    const res = await this._sendRequest(url, 'HEAD', signedHeaders);\n    return res.ok;\n  }\n\n  async _sign(method, path, query, headers, body) {\n    const datetime = new Date().toISOString().replace(/[:-]|\\.\\d{3}/g, '');\n    const url = new URL(path, this.endpoint);\n    url.pathname = `/${encodeURIComponent(this.bucketName)}${url.pathname}`;\n\n    const canonicalHeaders = this._buildCanonicalHeaders(headers);\n    const signedHeaders = Object.keys(headers)\n      .map(key => key.toLowerCase())\n      .sort()\n      .join(';');\n\n    const canonicalRequest = await this._buildCanonicalRequest(\n      method,\n      url,\n      query,\n      canonicalHeaders,\n      signedHeaders,\n      body,\n    );\n    const stringToSign = await this._buildStringToSign(datetime, canonicalRequest);\n    const signature = await this._calculateSignature(datetime, stringToSign);\n\n    const authorizationHeader = this._buildAuthorizationHeader(datetime, signedHeaders, signature);\n\n    headers[HEADER_AUTHORIZATION] = authorizationHeader;\n    headers[HEADER_AMZ_CONTENT_SHA256] = body ? await _hash(body) : UNSIGNED_PAYLOAD;\n    headers[HEADER_AMZ_DATE] = datetime;\n    headers[HEADER_HOST] = url.host;\n\n    return { url: url.toString(), headers };\n  }\n\n  _buildCanonicalHeaders(headers) {\n    return Object.entries(headers)\n      .map(([key, value]) => `${key.toLowerCase()}:${String(value).trim()}`)\n      .sort()\n      .join('\\n');\n  }\n\n  async _buildCanonicalRequest(method, url, query, canonicalHeaders, signedHeaders, body) {\n    return [\n      method,\n      encodeURI(url.pathname),\n      this._buildCanonicalQueryString(query),\n      `${canonicalHeaders}\\n`,\n      signedHeaders,\n      body ? await _hash(body) : UNSIGNED_PAYLOAD,\n    ].join('\\n');\n  }\n\n  async _buildStringToSign(datetime, canonicalRequest) {\n    const credentialScope = [datetime.slice(0, 8), this.region, S3_SERVICE, AWS_REQUEST_TYPE].join('/');\n    return [AWS_ALGORITHM, datetime, credentialScope, await _hash(canonicalRequest)].join('\\n');\n  }\n\n  async _calculateSignature(datetime, stringToSign) {\n    const signingKey = await this._getSignatureKey(datetime.slice(0, 8));\n    return _hmac(signingKey, stringToSign, 'hex');\n  }\n\n  _buildAuthorizationHeader(datetime, signedHeaders, signature) {\n    const credentialScope = [datetime.slice(0, 8), this.region, S3_SERVICE, AWS_REQUEST_TYPE].join('/');\n    return [\n      `${AWS_ALGORITHM} Credential=${this.accessKeyId}/${credentialScope}`,\n      `SignedHeaders=${signedHeaders}`,\n      `Signature=${signature}`,\n    ].join(', ');\n  }\n\n  /**\n   * List objects in the bucket.\n   * @param {string} [path='/'] - The path to list objects from.\n   * @param {string} [prefix=''] - The prefix to filter objects.\n   * @param {number} [maxKeys=1000] - The maximum number of keys to return.\n   * @param {string} [method='GET'] - The HTTP method to use (GET or HEAD).\n   * @param {Object} [opts={}] - Additional options for the list operation.\n   * @returns {Promise<Object|Array>} The list of objects or object metadata.\n   * @throws {TypeError} If any of the parameters are of incorrect type.\n   */\n  async list(path = '/', prefix = '', maxKeys = 1000, method = 'GET', opts = {}) {\n    if (typeof path !== 'string' || path.trim().length === 0) {\n      this._log('error', ERROR_PATH_REQUIRED);\n      throw new TypeError(ERROR_PATH_REQUIRED);\n    }\n    if (typeof prefix !== 'string') {\n      this._log('error', ERROR_PREFIX_TYPE);\n      throw new TypeError(ERROR_PREFIX_TYPE);\n    }\n    if (!Number.isInteger(maxKeys) || maxKeys <= 0) {\n      this._log('error', ERROR_MAX_KEYS_TYPE);\n      throw new TypeError(ERROR_MAX_KEYS_TYPE);\n    }\n    if (method !== 'GET' && method !== 'HEAD') {\n      this._log('error', `${ERROR_PREFIX}method must be either GET or HEAD`);\n      throw new TypeError(`${ERROR_PREFIX}method must be either GET or HEAD`);\n    }\n    if (typeof opts !== 'object') {\n      this._log('error', `${ERROR_PREFIX}opts must be an object`);\n      throw new TypeError(`${ERROR_PREFIX}opts must be an object`);\n    }\n    const query = {\n      'list-type': LIST_TYPE,\n      'max-keys': String(maxKeys),\n      ...opts,\n    };\n    const headers = {\n      [HEADER_CONTENT_TYPE]: JSON_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n    const { url, headers: signedHeaders } = await this._sign('GET', path, query, headers, '');\n    const urlWithQuery = `${url}?${new URLSearchParams(query)}`;\n\n    const res = await this._sendRequest(urlWithQuery, 'GET', signedHeaders);\n    const responseBody = await res.text();\n\n    if (method === 'HEAD') {\n      return {\n        size: +res.headers.get(HEADER_CONTENT_LENGTH),\n        mtime: new Date(res.headers.get(HEADER_LAST_MODIFIED)),\n        etag: res.headers.get(HEADER_ETAG),\n      };\n    }\n\n    const data = _parseXml(responseBody);\n    const output = data.listBucketResult || data.error || data;\n    return output.contents || output;\n  }\n\n  /**\n   * Get an object from the bucket.\n   * @param {string} key - The key of the object to get.\n   * @param {Object} [opts={}] - Additional options for the get operation.\n   * @returns {Promise<string>} The content of the object.\n   */\n  async get(key, opts = {}) {\n    const headers = {\n      [HEADER_CONTENT_TYPE]: JSON_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n    const { url, headers: signedHeaders } = await this._sign('GET', key, opts, headers, '');\n    const res = await this._sendRequest(url, 'GET', signedHeaders);\n    return res.text();\n  }\n\n  /**\n   * Get a stream of an object from the bucket.\n   * @param {string} key - The key of the object to get.\n   * @param {boolean} [wholeFile=true] - Whether to get the whole file or a part.\n   * @param {number} [part=0] - The part number to get if not getting the whole file.\n   * @param {number} [chunkSizeInB=this.maxRequestSizeInBytes] - The size of each chunk in bytes.\n   * @param {Object} [opts={}] - Additional options for the get operation.\n   * @returns {Promise<ReadableStream>} A readable stream of the object content.\n   */\n  async getStream(key, wholeFile = true, part = 0, chunkSizeInB = this.maxRequestSizeInBytes, opts = {}) {\n    const query = wholeFile ? opts : { partNumber: part, ...opts };\n    const headers = {\n      [HEADER_CONTENT_TYPE]: JSON_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n      ...(wholeFile ? {} : { range: `bytes=${part * chunkSizeInB}-${(part + 1) * chunkSizeInB - 1}` }),\n    };\n\n    const { url, headers: signedHeaders } = await this._sign('GET', key, query, headers, '');\n    const urlWithQuery = `${url}?${new URLSearchParams(query)}`;\n\n    const res = await this._sendRequest(urlWithQuery, 'GET', signedHeaders);\n    return res.body;\n  }\n\n  /**\n   * Put an object into the bucket.\n   * @param {string} key - The key of the object to put.\n   * @param {Buffer|string} data - The content of the object to put.\n   * @returns {Promise<Object>} The response from the put operation.\n   * @throws {TypeError} If the key is not a non-empty string or data is not a Buffer or string.\n   */\n  async put(key, data) {\n    if (typeof key !== 'string' || key.trim().length === 0) {\n      this._log('error', ERROR_KEY_REQUIRED);\n      throw new TypeError(ERROR_KEY_REQUIRED);\n    }\n    if (!(data instanceof Buffer || typeof data === 'string')) {\n      this._log('error', ERROR_DATA_BUFFER_REQUIRED);\n      throw new TypeError(ERROR_DATA_BUFFER_REQUIRED);\n    }\n    const headers = { [HEADER_CONTENT_LENGTH]: data.length };\n    const { url, headers: signedHeaders } = await this._sign('PUT', key, {}, headers, data);\n\n    const res = await this._sendRequest(url, 'PUT', signedHeaders, data);\n    return res;\n  }\n\n  /**\n   * Initiate a multipart upload.\n   * @param {string} key - The key of the object to upload.\n   * @param {string} [fileType='application/octet-stream'] - The MIME type of the file.\n   * @returns {Promise<string>} The upload ID for the multipart upload.\n   * @throws {TypeError} If the key is not a non-empty string or fileType is not a string.\n   * @throws {Error} If the multipart upload initiation fails.\n   */\n  async getMultipartUploadId(key, fileType = DEFAULT_STREAM_CONTENT_TYPE) {\n    if (typeof key !== 'string' || key.trim().length === 0) {\n      this._log('error', ERROR_KEY_REQUIRED);\n      throw new TypeError(ERROR_KEY_REQUIRED);\n    }\n    if (typeof fileType !== 'string') {\n      this._log('error', `${ERROR_PREFIX}fileType must be a string`);\n      throw new TypeError(`${ERROR_PREFIX}fileType must be a string`);\n    }\n    const query = { uploads: '' };\n    const headers = {\n      [HEADER_CONTENT_TYPE]: fileType,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n\n    const { url, headers: signedHeaders } = await this._sign('POST', key, query, headers, '');\n    const urlWithQuery = `${url}?${new URLSearchParams(query)}`;\n\n    const res = await this._sendRequest(urlWithQuery, 'POST', signedHeaders);\n    const responseBody = await res.text();\n    const parsedResponse = _parseXml(responseBody);\n\n    if (parsedResponse.error) {\n      this._log('error', `${ERROR_PREFIX}Failed to create multipart upload: ${parsedResponse.error.message}`);\n      throw new Error(`${ERROR_PREFIX}Failed to create multipart upload: ${parsedResponse.error.message}`);\n    }\n\n    if (!parsedResponse.initiateMultipartUploadResult || !parsedResponse.initiateMultipartUploadResult.uploadId) {\n      this._log('error', `${ERROR_PREFIX}Failed to create multipart upload: no uploadId in response`);\n      throw new Error(`${ERROR_PREFIX}Failed to create multipart upload: Missing upload ID in response`);\n    }\n\n    return parsedResponse.initiateMultipartUploadResult.uploadId;\n  }\n\n  /**\n   * Upload a part in a multipart upload.\n   * @param {string} key - The key of the object being uploaded.\n   * @param {Buffer|string} data - The content of the part.\n   * @param {string} uploadId - The upload ID of the multipart upload.\n   * @param {number} partNumber - The part number.\n   * @param {Object} [opts={}] - Additional options for the upload.\n   * @returns {Promise<Object>} The ETag and part number of the uploaded part.\n   * @throws {TypeError} If any of the parameters are of incorrect type.\n   */\n  async uploadPart(key, data, uploadId, partNumber, opts = {}) {\n    this._validateUploadPartParams(key, data, uploadId, partNumber, opts);\n    const query = { uploadId, partNumber, ...opts };\n    const headers = { [HEADER_CONTENT_LENGTH]: data.length };\n    const { url, headers: signedHeaders } = await this._sign('PUT', key, query, headers, data);\n    const urlWithQuery = `${url}?${new URLSearchParams(query)}`;\n\n    const res = await this._sendRequest(urlWithQuery, 'PUT', signedHeaders, data);\n    const etag = res.headers.get('etag');\n    return { etag, partNumber };\n  }\n\n  _validateUploadPartParams(key, data, uploadId, partNumber, opts) {\n    if (typeof key !== 'string' || key.trim().length === 0) {\n      this._log('error', ERROR_KEY_REQUIRED);\n      throw new TypeError(ERROR_KEY_REQUIRED);\n    }\n    if (!(data instanceof Buffer || typeof data === 'string')) {\n      this._log('error', ERROR_DATA_BUFFER_REQUIRED);\n      throw new TypeError(ERROR_DATA_BUFFER_REQUIRED);\n    }\n    if (typeof uploadId !== 'string' || uploadId.trim().length === 0) {\n      this._log('error', ERROR_UPLOAD_ID_REQUIRED);\n      throw new TypeError(ERROR_UPLOAD_ID_REQUIRED);\n    }\n    if (!Number.isInteger(partNumber) || partNumber <= 0) {\n      this._log('error', `${ERROR_PREFIX}partNumber must be a positive integer`);\n      throw new TypeError(`${ERROR_PREFIX}partNumber must be a positive integer`);\n    }\n    if (typeof opts !== 'object') {\n      this._log('error', `${ERROR_PREFIX}opts must be an object`);\n      throw new TypeError(`${ERROR_PREFIX}opts must be an object`);\n    }\n  }\n\n  /**\n   * Complete a multipart upload.\n   * @param {string} key - The key of the object being uploaded.\n   * @param {string} uploadId - The upload ID of the multipart upload.\n   * @param {Array<Object>} parts - An array of objects containing PartNumber and ETag for each part.\n   * @returns {Promise<Object>} The result of the complete multipart upload operation.\n   * @throws {TypeError} If any of the parameters are of incorrect type.\n   * @throws {Error} If the complete multipart upload operation fails.\n   */\n  async completeMultipartUpload(key, uploadId, parts) {\n    if (typeof key !== 'string' || key.trim().length === 0) {\n      this._log('error', ERROR_KEY_REQUIRED);\n      throw new TypeError(ERROR_KEY_REQUIRED);\n    }\n    if (typeof uploadId !== 'string' || uploadId.trim().length === 0) {\n      this._log('error', ERROR_UPLOAD_ID_REQUIRED);\n      throw new TypeError(ERROR_UPLOAD_ID_REQUIRED);\n    }\n    if (!Array.isArray(parts) || parts.length === 0) {\n      this._log('error', ERROR_PARTS_REQUIRED);\n      throw new TypeError(ERROR_PARTS_REQUIRED);\n    }\n    if (!parts.every(part => typeof part.PartNumber === 'number' && typeof part.ETag === 'string')) {\n      this._log('error', ERROR_INVALID_PART);\n      throw new TypeError(ERROR_INVALID_PART);\n    }\n    const query = { uploadId };\n    const xmlBody = this._buildCompleteMultipartUploadXml(parts);\n    const headers = {\n      [HEADER_CONTENT_TYPE]: XML_CONTENT_TYPE,\n      [HEADER_CONTENT_LENGTH]: Buffer.byteLength(xmlBody).toString(),\n      [HEADER_AMZ_CONTENT_SHA256]: await _hash(xmlBody),\n    };\n\n    const { url, headers: signedHeaders } = await this._sign('POST', key, query, headers, xmlBody);\n    const urlWithQuery = `${url}?${new URLSearchParams(query)}`;\n\n    const res = await this._sendRequest(urlWithQuery, 'POST', signedHeaders, xmlBody);\n    const responseBody = await res.text();\n    const parsedResponse = _parseXml(responseBody);\n\n    if (parsedResponse.error) {\n      this._log('error', `${ERROR_PREFIX}Failed to complete multipart upload: ${parsedResponse.error.message}`);\n      throw new Error(`${ERROR_PREFIX}Failed to complete multipart upload: ${parsedResponse.error.message}`);\n    }\n\n    return parsedResponse.completeMultipartUploadResult;\n  }\n\n  /**\n   * Aborts a multipart upload.\n   * @param {string} key - The key of the object being uploaded.\n   * @param {string} uploadId - The ID of the multipart upload to abort.\n   * @returns {Promise<Object>} - A promise that resolves to the abort response.\n   * @throws {Error} If the abort operation fails.\n   */\n  async abortMultipartUpload(key, uploadId) {\n    // Input validation\n    if (typeof key !== 'string' || key.trim().length === 0) {\n      this._log('error', ERROR_KEY_REQUIRED);\n      throw new TypeError(ERROR_KEY_REQUIRED);\n    }\n    if (typeof uploadId !== 'string' || uploadId.trim().length === 0) {\n      this._log('error', ERROR_UPLOAD_ID_REQUIRED);\n      throw new TypeError(ERROR_UPLOAD_ID_REQUIRED);\n    }\n\n    // Prepare the request\n    const query = { uploadId };\n    const headers = {\n      [HEADER_CONTENT_TYPE]: XML_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n\n    try {\n      // Sign and send the request\n      const { url, headers: signedHeaders } = await this._sign('DELETE', key, query, headers, '');\n      const urlWithQuery = `${url}?${new URLSearchParams(query)}`;\n\n      const res = await this._sendRequest(urlWithQuery, 'DELETE', signedHeaders);\n\n      // Check for successful response\n      if (res.ok) {\n        const responseBody = await res.text();\n        const parsedResponse = _parseXml(responseBody);\n\n        if (parsedResponse.error) {\n          this._log('error', `${ERROR_PREFIX}Failed to abort multipart upload: ${parsedResponse.error.message}`);\n          throw new Error(`${ERROR_PREFIX}Failed to abort multipart upload: ${parsedResponse.error.message}`);\n        }\n\n        return {\n          status: 'Aborted',\n          key,\n          uploadId,\n          response: parsedResponse,\n        };\n      } else {\n        this._log('error', `${ERROR_PREFIX}Abort request failed with status ${res.status}`);\n        throw new Error(`${ERROR_PREFIX}Abort request failed with status ${res.status}`);\n      }\n    } catch (error) {\n      this._log('error', `${ERROR_PREFIX}Failed to abort multipart upload for key ${key}: ${error.message}`);\n      throw new Error(`${ERROR_PREFIX}Failed to abort multipart upload for key ${key}: ${error.message}`);\n    }\n  }\n\n  _buildCompleteMultipartUploadXml(parts) {\n    return `\n      <CompleteMultipartUpload>\n        ${parts\n          .map(\n            part => `\n          <Part>\n            <PartNumber>${part.PartNumber}</PartNumber>\n            <ETag>${part.ETag}</ETag>\n          </Part>\n        `,\n          )\n          .join('')}\n      </CompleteMultipartUpload>\n    `;\n  }\n\n  /**\n   * Delete an object from the bucket.\n   * @param {string} path - The key of the object to delete.\n   * @returns {Promise<Object>} The response from the delete operation.\n   */\n  async delete(path) {\n    const { url, headers: signedHeaders } = await this._sign('DELETE', path, {}, {}, '');\n    const res = await this._sendRequest(url, 'DELETE', signedHeaders);\n    return res.json();\n  }\n\n  async _sendRequest(url, method, headers, body = null) {\n    const res = await fetch(url, {\n      method,\n      headers,\n      body,\n      signal: this.requestAbortTimeout !== undefined ? AbortSignal.timeout(this.requestAbortTimeout) : undefined,\n    });\n\n    if (!res.ok) {\n      await this._handleErrorResponse(res);\n    }\n\n    return res;\n  }\n\n  async _handleErrorResponse(res) {\n    const errorBody = await res.text();\n    const errorCode = res.headers.get('x-amz-error-code') || 'Unknown';\n    const errorMessage = res.headers.get('x-amz-error-message') || res.statusText;\n    this._log(\n      'error',\n      `${ERROR_PREFIX}Request failed with status ${res.status}: ${errorCode} - ${errorMessage},err body: ${errorBody}`,\n    );\n    throw new Error(\n      `${ERROR_PREFIX}Request failed with status ${res.status}: ${errorCode} - ${errorMessage}, err body: ${errorBody}`,\n    );\n  }\n\n  _buildCanonicalQueryString(queryParams) {\n    if (Object.keys(queryParams).length < 1) {\n      return '';\n    }\n\n    return Object.keys(queryParams)\n      .sort()\n      .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(queryParams[key])}`)\n      .join('&');\n  }\n  async _getSignatureKey(dateStamp) {\n    const kDate = await _hmac(`AWS4${this.secretAccessKey}`, dateStamp);\n    const kRegion = await _hmac(kDate, this.region);\n    const kService = await _hmac(kRegion, S3_SERVICE);\n    return _hmac(kService, AWS_REQUEST_TYPE);\n  }\n}\n\nconst _hash = async content => {\n  const hashSum = _createHash('sha256');\n  hashSum.update(content);\n  return hashSum.digest('hex');\n};\n\nconst _hmac = async (key, content, encoding) => {\n  const hmacSum = _createHmac('sha256', key);\n  hmacSum.update(content);\n  return hmacSum.digest(encoding);\n};\n\nconst _parseXml = str => {\n  const unescapeXml = value => {\n    return value\n      .replace(/&quot;/g, '\"')\n      .replace(/&apos;/g, \"'\")\n      .replace(/&lt;/g, '<')\n      .replace(/&gt;/g, '>')\n      .replace(/&amp;/g, '&');\n  };\n\n  const json = {};\n  const re = /<(\\w)([-\\w]+)(?:\\/|[^>]*>((?:(?!<\\1)[\\s\\S])*)<\\/\\1\\2)>/gm;\n  let match;\n\n  while ((match = re.exec(str))) {\n    const [, prefix, key, value] = match;\n    const fullKey = prefix.toLowerCase() + key;\n    const parsedValue = value != null ? _parseXml(value) : true;\n\n    if (typeof parsedValue === 'string') {\n      json[fullKey] = unescapeXml(parsedValue); // Apply unescapeXml here\n    } else if (Array.isArray(json[fullKey])) {\n      json[fullKey].push(parsedValue);\n    } else {\n      json[fullKey] =\n        json[fullKey] != null ? [json[fullKey], parsedValue] : expectArray[fullKey] ? [parsedValue] : parsedValue;\n    }\n  }\n\n  return Object.keys(json).length ? json : unescapeXml(str); // Also apply unescapeXml here for root text nodes\n};\n\nexport { S3 };\nexport default S3;\n"],
  "mappings": "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",
  "names": ["_createHmac", "m", "_createHash", "AWS_ALGORITHM", "AWS_REQUEST_TYPE", "S3_SERVICE", "LIST_TYPE", "UNSIGNED_PAYLOAD", "DEFAULT_STREAM_CONTENT_TYPE", "XML_CONTENT_TYPE", "JSON_CONTENT_TYPE", "SENSITIVE_KEYS_REDACTED", "HEADER_AMZ_CONTENT_SHA256", "HEADER_AMZ_DATE", "HEADER_HOST", "HEADER_AUTHORIZATION", "HEADER_CONTENT_TYPE", "HEADER_CONTENT_LENGTH", "HEADER_ETAG", "HEADER_LAST_MODIFIED", "ERROR_PREFIX", "ERROR_ACCESS_KEY_REQUIRED", "ERROR_SECRET_KEY_REQUIRED", "ERROR_ENDPOINT_REQUIRED", "ERROR_BUCKET_NAME_REQUIRED", "ERROR_KEY_REQUIRED", "ERROR_UPLOAD_ID_REQUIRED", "ERROR_PARTS_REQUIRED", "ERROR_INVALID_PART", "ERROR_DATA_BUFFER_REQUIRED", "ERROR_PATH_REQUIRED", "ERROR_PREFIX_TYPE", "ERROR_MAX_KEYS_TYPE", "expectArray", "S3", "accessKeyId", "secretAccessKey", "endpoint", "bucketName", "region", "maxRequestSizeInBytes", "requestAbortTimeout", "logger", "level", "message", "additionalData", "sanitize", "obj", "acc", "key", "sanitizedData", "logEntry", "props", "headers", "url", "signedHeaders", "contentLength", "method", "path", "query", "body", "datetime", "canonicalHeaders", "canonicalRequest", "stringToSign", "signature", "authorizationHeader", "_hash", "value", "credentialScope", "signingKey", "_hmac", "prefix", "maxKeys", "opts", "urlWithQuery", "res", "responseBody", "data", "_parseXml", "output", "wholeFile", "part", "chunkSizeInB", "fileType", "parsedResponse", "uploadId", "partNumber", "parts", "xmlBody", "error", "errorBody", "errorCode", "errorMessage", "queryParams", "dateStamp", "kDate", "kRegion", "kService", "content", "hashSum", "encoding", "hmacSum", "str", "unescapeXml", "json", "re", "match", "fullKey", "parsedValue", "src_default", "S3"]
}
