{
  "version": 3,
  "sources": ["../src/index.js"],
  "sourcesContent": ["'use strict';\n\nimport { createHmac, createHash } from 'node:crypto';\n\nconst expectArray = {\n  contents: true,\n};\n\nclass S3 {\n  constructor({ accessKeyId, secretAccessKey, endpoint, bucketName = '', region = 'auto' }) {\n    if (typeof accessKeyId !== 'string' || accessKeyId.length === 0)\n      throw new TypeError('accessKeyId must be a non-empty string');\n    if (typeof secretAccessKey !== 'string' || secretAccessKey.length === 0)\n      throw new TypeError('secretAccessKey must be a non-empty string');\n    if (typeof endpoint !== 'string' || endpoint.length === 0)\n      throw new TypeError('endpoint must be a non-empty string');\n    this.accessKeyId = accessKeyId;\n    this.secretAccessKey = secretAccessKey;\n    this.endpoint = endpoint;\n    this.bucketName = bucketName;\n    this.region = region;\n  }\n\n  getBucketName = () => {\n    return this.bucketName;\n  };\n\n  getRegion = () => {\n    return this.region;\n  };\n\n  getEndpoint = () => {\n    return this.endpoint;\n  };\n\n  getProps = () => {\n    return {\n      accessKeyId: this.accessKeyId,\n      secretAccessKey: this.secretAccessKey,\n      region: this.region,\n      bucket: this.bucket,\n    };\n  };\n\n  async sign(method, path, query, headers, body) {\n    const datetime = new Date().toISOString().replace(/[:-]|\\.\\d{3}/g, '');\n    const url = new URL(path, this.endpoint);\n    const encodedBucketName = encodeURIComponent(this.bucketName);\n    url.pathname = `/${encodedBucketName}${url.pathname}`;\n    const canonicalHeaders = Object.entries(headers)\n      .map(([key, value]) => `${key.toLowerCase()}:${String(value).trim()}`)\n      .sort()\n      .join('\\n');\n    const signedHeaders = Object.keys(headers)\n      .map(key => key.toLowerCase())\n      .sort()\n      .join(';');\n    const canonicalRequest = [\n      method,\n      encodeURI(url.pathname),\n      buildCanonicalQueryString(query),\n      canonicalHeaders + '\\n',\n      signedHeaders,\n      body ? await hash(body) : 'UNSIGNED-PAYLOAD',\n    ].join('\\n');\n    const credentialScope = [datetime.slice(0, 8), this.region, 's3', 'aws4_request'].join('/');\n    const stringToSign = ['AWS4-HMAC-SHA256', datetime, credentialScope, await hash(canonicalRequest)].join('\\n');\n    const signingKey = await getSignatureKey(this.secretAccessKey, datetime.slice(0, 8), this.region, 's3');\n    const signature = await hmac(signingKey, stringToSign, 'hex');\n\n    const authorizationHeader = [\n      'AWS4-HMAC-SHA256 Credential=' + this.accessKeyId + '/' + credentialScope,\n      'SignedHeaders=' + signedHeaders,\n      'Signature=' + signature,\n    ].join(', ');\n\n    headers['Authorization'] = authorizationHeader;\n    headers['x-amz-content-sha256'] = body ? await hash(body) : 'UNSIGNED-PAYLOAD';\n    headers['x-amz-date'] = datetime;\n    headers['host'] = url.host;\n\n    return {\n      url: url.toString(),\n      headers: headers,\n    };\n  }\n\n  async list(path = '/', prefix = '', maxKeys = 1000, method = 'GET') {\n    const query = {\n      'list-type': '2',\n      'max-keys': String(maxKeys),\n    };\n    const headers = {\n      'Content-Type': 'application/json',\n      'x-amz-content-sha256': 'UNSIGNED-PAYLOAD',\n    };\n    const { url, headers: signedHeaders } = await this.sign('GET', path, query, headers, '');\n    const searchParams = new URLSearchParams(query);\n    const urlWithQuery = `${url}?${searchParams.toString()}`;\n    const res = await fetch(urlWithQuery, { headers: signedHeaders });\n\n    if (!res.ok) {\n      const errorBody = await res.text();\n      console.log('Error Body:', errorBody);\n      const errorCode = res.headers.get('x-amz-error-code') || 'Unknown';\n      const errorMessage = res.headers.get('x-amz-error-message') || res.statusText;\n      throw new Error(`ListV2 failed with status ${res.status}: ${errorCode} - ${errorMessage}`);\n    }\n\n    let data = [];\n    let responseBody = await res.text();\n    if (res.statusCode > 299) {\n      data =\n        (method !== 'HEAD' && parseXml(responseBody).error) ||\n        (path ? 'The specified key does not exist.' : 'The specified bucket is not valid.');\n      throw new Error('yadada: ' + errorMessage);\n    }\n    data =\n      method === 'GET'\n        ? parseXml(responseBody)\n        : {\n            size: +res.headers['content-length'],\n            mtime: new Date(res.headers['last-modified']),\n            etag: res.headers.etag,\n          };\n    const output = data.listBucketResult || data.error || data;\n    return output.contents || output;\n  }\n\n  async get(key, opts) {\n    const query = opts || {};\n    const headers = {\n      'Content-Type': 'application/json',\n      'x-amz-content-sha256': 'UNSIGNED-PAYLOAD',\n    };\n    const { url, headers: signedHeaders } = await this.sign('GET', key, query, headers, '');\n    const res = await fetch(url, { headers: signedHeaders });\n\n    if (!res.ok) {\n      const errorBody = await res.text();\n      console.error('Error Body:', errorBody);\n      const errorCode = res.headers.get('x-amz-error-code') || 'Unknown';\n      const errorMessage = res.headers.get('x-amz-error-message') || res.statusText;\n      throw new Error(`GET failed with status ${res.status}: ${errorCode} - ${errorMessage}`);\n    }\n\n    return res.text();\n  }\n\n  async put(key, data, opts) {\n    const query = opts || {};\n    const headers = {\n      'Content-Length': data.length,\n    };\n    const { url, headers: signedHeaders } = await this.sign('PUT', key, query, headers, data);\n    const res = await fetch(url, { method: 'PUT', headers: signedHeaders, body: data });\n\n    if (!res.ok) {\n      const errorBody = await res.text();\n      console.error('Error Body:', errorBody);\n      const errorCode = res.headers.get('x-amz-error-code') || 'Unknown';\n      const errorMessage = res.headers.get('x-amz-error-message') || res.statusText;\n      throw new Error(`PUT failed with status ${res.status}: ${errorCode} - ${errorMessage}`);\n    }\n\n    return res;\n  }\n\n  async delete(path, opts) {\n    const query = opts || {};\n    const headers = {};\n    const { url, headers: signedHeaders } = await this.sign('DELETE', path, query, headers, '');\n    const res = await fetch(url, { method: 'DELETE', headers: signedHeaders });\n\n    if (!res.ok) {\n      const errorBody = await res.text();\n      console.error('Error Body:', errorBody);\n      const errorCode = res.headers.get('x-amz-error-code') || 'Unknown';\n      const errorMessage = res.headers.get('x-amz-error-message') || res.statusText;\n      throw new Error(`DELETE failed with status ${res.status}: ${errorCode} - ${errorMessage}`);\n    }\n\n    return res.json();\n  }\n}\n\nconst buildCanonicalQueryString = queryParams => {\n  if (Object.keys(queryParams).length < 1) {\n    return '';\n  }\n\n  const sortedQueryParams = Object.keys(queryParams).sort();\n\n  let canonicalQueryString = '';\n  for (let i = 0; i < sortedQueryParams.length; i++) {\n    canonicalQueryString +=\n      encodeURIComponent(sortedQueryParams[i]) + '=' + encodeURIComponent(queryParams[sortedQueryParams[i]]) + '&';\n  }\n  return canonicalQueryString.slice(0, -1);\n};\n\nconst getSignatureKey = async (secretAccessKey, dateStamp, region, serviceName) => {\n  const kDate = await hmac(`AWS4${secretAccessKey}`, dateStamp);\n  const kRegion = await hmac(kDate, region);\n  const kService = await hmac(kRegion, serviceName);\n  const kSigning = await hmac(kService, 'aws4_request');\n  return kSigning;\n};\n\nconst hash = async content => {\n  const hashSum = createHash('sha256');\n  hashSum.update(content);\n  return hashSum.digest('hex');\n};\n\nconst hmac = async (key, content, encoding) => {\n  const hmacSum = createHmac('sha256', key);\n  hmacSum.update(content);\n  return hmacSum.digest(encoding);\n};\n\nconst parseXml = str => {\n  const unescapeXml = value => {\n    return value\n      .replace(/&quot;/g, '\"')\n      .replace(/&apos;/g, \"'\")\n      .replace(/&lt;/g, '<')\n      .replace(/&gt;/g, '>')\n      .replace(/&amp;/g, '&');\n  };\n\n  let key, val;\n  const json = {};\n  const re = /<(\\w)([-\\w]+)(?:\\/|[^>]*>((?:(?!<\\1)[\\s\\S])*)<\\/\\1\\2)>/gm;\n  for (; (val = re.exec(str)); ) {\n    key = val[1].toLowerCase() + val[2];\n    val = val[3] != null ? parseXml(val[3]) : true;\n    if (typeof val === 'string') {\n      val = unescapeXml(val);\n    }\n    if (Array.isArray(json[key])) json[key].push(val);\n    else json[key] = json[key] != null ? [json[key], val] : expectArray[key] ? [val] : val;\n  }\n  return key ? json : str;\n};\n\nexport { S3 };\nexport default S3;\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "S3", "src_default", "__toCommonJS", "import_node_crypto", "expectArray", "accessKeyId", "secretAccessKey", "endpoint", "bucketName", "region", "method", "path", "query", "headers", "body", "datetime", "url", "encodedBucketName", "canonicalHeaders", "key", "value", "signedHeaders", "canonicalRequest", "buildCanonicalQueryString", "hash", "credentialScope", "stringToSign", "signingKey", "getSignatureKey", "signature", "hmac", "authorizationHeader", "prefix", "maxKeys", "searchParams", "urlWithQuery", "res", "errorBody", "errorCode", "errorMessage", "data", "responseBody", "parseXml", "output", "opts", "queryParams", "sortedQueryParams", "canonicalQueryString", "i", "dateStamp", "serviceName", "kDate", "kRegion", "kService", "content", "hashSum", "encoding", "hmacSum", "str", "unescapeXml", "val", "json", "re", "src_default", "S3"]
}
