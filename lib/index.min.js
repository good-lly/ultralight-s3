var N="AWS4-HMAC-SHA256",U="aws4_request",K="s3",v="2",_="UNSIGNED-PAYLOAD",Y="application/octet-stream",M="application/xml",R="application/json",W=["accessKeyId","secretAccessKey","sessionToken","password"];var E="x-amz-content-sha256",X="x-amz-date",Z="host",V="Authorization",y="Content-Type",T="Content-Length",P="etag",C="last-modified",h="ultralight-s3 Module: ",J=`${h}accessKeyId must be a non-empty string`,ee=`${h}secretAccessKey must be a non-empty string`,te=`${h}endpoint must be a non-empty string`,se=`${h}bucketName must be a non-empty string`,x=`${h}key must be a non-empty string`,$=`${h}uploadId must be a non-empty string`,L=`${h}parts must be a non-empty array`,j=`${h}Each part must have a partNumber (number) and ETag (string)`,I=`${h}data must be a Buffer or string`,k=`${h}prefix must be a string`,B=`${h}maxKeys must be a positive integer`,F=`${h}delimiter must be a string`;var G=crypto.createHmac||(await import("node:crypto")).createHmac,z=crypto.createHash||(await import("node:crypto")).createHash;typeof G>"u"&&typeof z>"u"&&console.error("ultralight-S3 Module: Crypto functions are not available, please report the issue with necessary description: https://github.com/sentienhq/ultralight-s3/issues");var re={contents:!0},ne=f=>`%${f.charCodeAt(0).toString(16).toUpperCase()}`,O=f=>encodeURIComponent(f).replace(/[!'()*]/g,ne),m=f=>O(f).replace(/%2F/g,"/"),q=class{constructor({accessKeyId:e,secretAccessKey:t,endpoint:s,bucketName:r,region:o="auto",maxRequestSizeInBytes:i=5242880,requestAbortTimeout:a=void 0,logger:c=void 0}){this.getBucketName=()=>this.bucketName,this.setBucketName=n=>{this.bucketName=n},this.getRegion=()=>this.region,this.setRegion=n=>{this.region=n},this.getEndpoint=()=>this.endpoint,this.setEndpoint=n=>{this.endpoint=n},this.getMaxRequestSizeInBytes=()=>this.maxRequestSizeInBytes,this.setMaxRequestSizeInBytes=n=>{this.maxRequestSizeInBytes=n},this.getProps=()=>({accessKeyId:this.accessKeyId,secretAccessKey:this.secretAccessKey,region:this.region,bucket:this.bucketName,endpoint:this.endpoint,maxRequestSizeInBytes:this.maxRequestSizeInBytes,requestAbortTimeout:this.requestAbortTimeout,logger:this.logger}),this.setProps=n=>{this._validateConstructorParams(n.accessKeyId,n.secretAccessKey,n.bucketName,n.endpoint),this.accessKeyId=n.accessKeyId,this.secretAccessKey=n.secretAccessKey,this.region=n.region||"auto",this.bucketName=n.bucketName,this.endpoint=n.endpoint,this.maxRequestSizeInBytes=n.maxRequestSizeInBytes||5242880,this.requestAbortTimeout=n.requestAbortTimeout,this.logger=n.logger},this._validateConstructorParams(e,t,s,r),this.accessKeyId=e,this.secretAccessKey=t,this.endpoint=s,this.bucketName=r,this.region=o,this.maxRequestSizeInBytes=i,this.requestAbortTimeout=a,this.logger=c}_validateConstructorParams(e,t,s,r){if(typeof e!="string"||e.trim().length===0)throw new TypeError(J);if(typeof t!="string"||t.trim().length===0)throw new TypeError(ee);if(typeof s!="string"||s.trim().length===0)throw new TypeError(te);if(typeof r!="string"||r.trim().length===0)throw new TypeError(se)}_checkMethodHeadnGet(e){if(e!=="GET"&&e!=="HEAD")throw this._log("error",`${h}method must be either GET or HEAD`),new Error("method must be either GET or HEAD")}_checkKey(e){if(typeof e!="string"||e.trim().length===0)throw this._log("error",x),new TypeError(x)}_checkDelimiter(e){if(typeof e!="string"||e.trim().length===0)throw this._log("error",F),new TypeError(F)}_checkPrefix(e){if(typeof e!="string")throw this._log("error",k),new TypeError(k)}_checkMaxKeys(e){if(typeof e!="number"||e<=0)throw this._log("error",B),new TypeError(B)}_checkOpts(e){if(typeof e!="object")throw this._log("error",`${h}opts must be an object`),new TypeError(`${h}opts must be an object`)}_log(e,t,s={}){if(this.logger&&typeof this.logger[e]=="function"){let r=a=>typeof a!="object"||a===null?a:Object.keys(a).reduce((c,n)=>(W.includes(n.toLowerCase())?c[n]="[REDACTED]":typeof a[n]=="object"&&a[n]!==null?c[n]=r(a[n]):c[n]=a[n],c),Array.isArray(a)?[]:{}),o=r(s),i={timestamp:new Date().toISOString(),level:e,message:t,...o,context:r({bucketName:this.bucketName,region:this.region,endpoint:this.endpoint,accessKeyId:this.accessKeyId?`${this.accessKeyId.substring(0,4)}...`:void 0})};this.logger[e](i)}}async getContentLength(e){this._checkKey(e);let t={[E]:_},s=m(e),{url:r,headers:o}=await this._sign("HEAD",s,{},t,""),a=(await this._sendRequest(r,"HEAD",o)).headers.get(T);return a?parseInt(a,10):0}async bucketExists(){let e={[E]:_},{url:t,headers:s}=await this._sign("HEAD","",{},e,""),r=await this._sendRequest(t,"HEAD",s);return!!(r.ok&&r.status===200)}async fileExists(e){this._checkKey(e);let t={[E]:_},s=m(e),{url:r,headers:o}=await this._sign("HEAD",s,{},t,"");try{let i=await fetch(r,{method:"HEAD",headers:o});return i.ok&&i.status===200?!0:(i.status===404||this._handleErrorResponse(i),!1)}catch(i){let a=i instanceof Error?i.message:String(i);throw this._log("error",`${h}Failed to check if file exists: ${a}`),new Error(`${h}Failed to check if file exists: ${a}`)}}async _sign(e,t,s,r,o){let i=new Date().toISOString().replace(/[:-]|\.\d{3}/g,""),a=typeof t=="string"&&t.length>0?new URL(t,this.endpoint):new URL(this.endpoint);a.pathname=`/${encodeURI(this.bucketName)}${a.pathname}`,r[E]=o?await D(o):_,r[X]=i,r[Z]=a.host;let c=this._buildCanonicalHeaders(r),n=Object.keys(r).map(p=>p.toLowerCase()).sort().join(";"),l=await this._buildCanonicalRequest(e,a,s,c,n,o),u=await this._buildStringToSign(i,l),d=await this._calculateSignature(i,u),g=this._buildAuthorizationHeader(i,n,d);return r[V]=g,{url:a.toString(),headers:r}}_buildCanonicalHeaders(e){return Object.entries(e).map(([t,s])=>`${t.toLowerCase()}:${String(s).trim()}`).sort().join(`
`)}async _buildCanonicalRequest(e,t,s,r,o,i){return[e,t.pathname,this._buildCanonicalQueryString(s),`${r}
`,o,i?await D(i):_].join(`
`)}async _buildStringToSign(e,t){let s=[e.slice(0,8),this.region,K,U].join("/");return[N,e,s,await D(t)].join(`
`)}async _calculateSignature(e,t){let s=await this._getSignatureKey(e.slice(0,8));return A(s,t,"hex")}_buildAuthorizationHeader(e,t,s){let r=[e.slice(0,8),this.region,K,U].join("/");return[`${N} Credential=${this.accessKeyId}/${r}`,`SignedHeaders=${t}`,`Signature=${s}`].join(", ")}_filterIfHeaders(e){let t={},s={},r=["if-match","if-none-match","if-modified-since","if-unmodified-since"];for(let[o,i]of Object.entries(e))r.includes(o)?s[o]=i:t[o]=i;return{filteredOpts:t,conditionalHeaders:s}}async list(e="/",t="",s=1e3,r="GET",o={}){this._checkDelimiter(e),this._checkPrefix(t),this._checkMaxKeys(s),this._checkMethodHeadnGet(r),this._checkOpts(o),this._log("info",`Listing objects in ${t}`);let i={"list-type":v,"max-keys":String(s),...o};t.length>0&&(i.prefix=t);let a={[y]:R,[E]:_},c=e==="/"?e:O(e),{url:n,headers:l}=await this._sign("GET",c,i,a,""),u=`${n}?${new URLSearchParams(i)}`,d=await this._sendRequest(u,"GET",l),g=await d.text();if(r==="HEAD"){let w=d.headers.get(T),S=d.headers.get(C),Q=d.headers.get(P);return{size:w?+w:void 0,mtime:S?new Date(S):void 0,ETag:Q||void 0}}let p=b(g),H=p.listBucketResult||p.error||p;return H.contents||H}async listMultiPartUploads(e="/",t="",s="GET",r={}){var o,i,a;this._checkDelimiter(e),this._checkPrefix(t),this._checkMethodHeadnGet(s),this._checkOpts(r),this._log("info",`Listing multipart uploads in ${t}`);let c={uploads:"",...r},n={[y]:R,[E]:_},l=e==="/"?e:O(e),{url:u,headers:d}=await this._sign("GET",l,c,n,""),g=`${u}?${new URLSearchParams(c)}`,p=await this._sendRequest(g,"GET",d),H=await p.text();if(s==="HEAD")return{size:+((o=p.headers.get(T))!==null&&o!==void 0?o:"0"),mtime:new Date((i=p.headers.get(C))!==null&&i!==void 0?i:""),ETag:(a=p.headers.get(P))!==null&&a!==void 0?a:""};let w=b(H),S=w.listMultipartUploadsResult||w.error||w;return S.uploads||S}async get(e,t={}){this._checkKey(e),this._log("info",`Getting object ${e}`);let{filteredOpts:s,conditionalHeaders:r}=this._filterIfHeaders(t),o={[y]:R,[E]:_,...r},i=m(e),{url:a,headers:c}=await this._sign("GET",i,s,o,"");return(await this._sendRequest(a,"GET",c)).text()}async getObjectWithETag(e,t={}){this._checkKey(e),this._log("info",`Getting object ${e}`);let{filteredOpts:s,conditionalHeaders:r}=this._filterIfHeaders(t),o={[y]:R,[E]:_,...r},i=m(e),{url:a,headers:c}=await this._sign("GET",i,s,o,"");try{let n=await this._sendRequest(a,"GET",c);if(!n.ok)throw new Error(`Failed to get object. Status: ${n.status}`);let l=n.headers.get("etag");if(!l)throw new Error("ETag not found in response headers");let u=await n.text();return{etag:l,data:u}}catch(n){throw this._log("error",`Error getting object ${e} with ETag: ${n}`),n}}async getEtag(e,t={}){this._checkKey(e),this._log("info",`Getting etag object ${e}`);let{filteredOpts:s,conditionalHeaders:r}=this._filterIfHeaders(t),o={[y]:R,[E]:_,...r},i=m(e),{url:a,headers:c}=await this._sign("HEAD",i,s,o,""),n=await this._sendRequest(a,"HEAD",c);if(this._log("info",`Response status: ${n.status,n.statusText}`),!n.ok&&n.status===412)return null;let l=n.headers.get("etag");if(!l)throw new Error("ETag not found in response headers");return l}async getResponse(e,t=!0,s=0,r=this.maxRequestSizeInBytes,o={}){this._checkKey(e);let{filteredOpts:i,conditionalHeaders:a}=this._filterIfHeaders(o),c={[y]:R,[E]:_,...a},n=m(e),{url:l,headers:u}=await this._sign("GET",n,i,c,""),d=`${l}?${new URLSearchParams(i)}`;return this._sendRequest(d,"GET",u)}async put(e,t){if(this._checkKey(e),!(t instanceof Buffer||typeof t=="string"))throw this._log("error",I),new TypeError(I);this._log("info",`Uploading object ${e}`);let s=typeof t=="string"?Buffer.byteLength(t):t.length,r={[T]:s},o=m(e),{url:i,headers:a}=await this._sign("PUT",o,{},r,t);return await this._sendRequest(i,"PUT",a,t)}async getMultipartUploadId(e,t=Y){if(this._checkKey(e),typeof t!="string")throw this._log("error",`${h}fileType must be a string`),new TypeError(`${h}fileType must be a string`);this._log("info",`Initiating multipart upload for object ${e}`);let s={uploads:""},r={[y]:t,[E]:_},o=m(e),{url:i,headers:a}=await this._sign("POST",o,s,r,""),c=`${i}?${new URLSearchParams(s)}`,l=await(await this._sendRequest(c,"POST",a)).text(),u=b(l);if(typeof u=="object"&&u!==null&&"error"in u&&typeof u.error=="object"&&u.error!==null&&"message"in u.error){let d=String(u.error.message);throw this._log("error",`${h}Failed to abort multipart upload: ${d}`),new Error(`${h}Failed to abort multipart upload: ${d}`)}if(typeof u=="object"&&u!==null){if(!u.initiateMultipartUploadResult||!u.initiateMultipartUploadResult.uploadId)throw this._log("error",`${h}Failed to create multipart upload: no uploadId in response`),new Error(`${h}Failed to create multipart upload: Missing upload ID in response`);return u.initiateMultipartUploadResult.uploadId}else throw this._log("error",`${h}Failed to create multipart upload: unexpected response format`),new Error(`${h}Failed to create multipart upload: Unexpected response format`)}async uploadPart(e,t,s,r,o={}){this._validateUploadPartParams(e,t,s,r,o);let i={uploadId:s,partNumber:r,...o},a={[T]:t.length},c=m(e),{url:n,headers:l}=await this._sign("PUT",c,i,a,t),u=`${n}?${new URLSearchParams(i)}`,g=(await this._sendRequest(u,"PUT",l,t)).headers.get("etag")||"";return{partNumber:r,ETag:g}}_validateUploadPartParams(e,t,s,r,o){if(this._checkKey(e),!(t instanceof Buffer||typeof t=="string"))throw this._log("error",I),new TypeError(I);if(typeof s!="string"||s.trim().length===0)throw this._log("error",$),new TypeError($);if(!Number.isInteger(r)||r<=0)throw this._log("error",`${h}partNumber must be a positive integer`),new TypeError(`${h}partNumber must be a positive integer`);this._checkOpts(o)}async completeMultipartUpload(e,t,s){if(this._checkKey(e),typeof t!="string"||t.trim().length===0)throw this._log("error",$),new TypeError($);if(!Array.isArray(s)||s.length===0)throw this._log("error",L),new TypeError(L);if(!s.every(p=>typeof p.partNumber=="number"&&typeof p.ETag=="string"))throw this._log("error",j),new TypeError(j);this._log("info",`Complete multipart upload ${t} for object ${e}`);let r={uploadId:t},o=this._buildCompleteMultipartUploadXml(s),i={[y]:M,[T]:Buffer.byteLength(o).toString(),[E]:await D(o)},a=m(e),{url:c,headers:n}=await this._sign("POST",a,r,i,o),l=`${c}?${new URLSearchParams(r)}`,d=await(await this._sendRequest(l,"POST",n,o)).text(),g=b(d);if(typeof g=="object"&&g!==null&&"error"in g&&typeof g.error=="object"&&g.error!==null&&"message"in g.error){let p=String(g.error.message);throw this._log("error",`${h}Failed to abort multipart upload: ${p}`),new Error(`${h}Failed to abort multipart upload: ${p}`)}return g.completeMultipartUploadResult}async abortMultipartUpload(e,t){if(this._checkKey(e),typeof t!="string"||t.trim().length===0)throw this._log("error",$),new TypeError($);this._log("info",`Aborting multipart upload ${t} for object ${e}`);let s={uploadId:t},r={[y]:M,[E]:_};try{let o=m(e),{url:i,headers:a}=await this._sign("DELETE",o,s,r,""),c=`${i}?${new URLSearchParams(s)}`,n=await this._sendRequest(c,"DELETE",a);if(n.ok){let l=await n.text(),u=b(l);if(typeof u=="object"&&u!==null&&"error"in u&&typeof u.error=="object"&&u.error!==null&&"message"in u.error){let d=String(u.error.message);throw this._log("error",`${h}Failed to abort multipart upload: ${d}`),new Error(`${h}Failed to abort multipart upload: ${d}`)}return{status:"Aborted",key:e,uploadId:t,response:u}}else throw this._log("error",`${h}Abort request failed with status ${n.status}`),new Error(`${h}Abort request failed with status ${n.status}`)}catch(o){let i=o instanceof Error?o.message:String(o);throw this._log("error",`${h}Failed to abort multipart upload for key ${e}: ${i}`),new Error(`${h}Failed to abort multipart upload for key ${e}: ${i}`)}}_buildCompleteMultipartUploadXml(e){return`
      <CompleteMultipartUpload>
        ${e.map(t=>`
          <Part>
            <PartNumber>${t.partNumber}</PartNumber>
            <ETag>${t.ETag}</ETag>
          </Part>
        `).join("")}
      </CompleteMultipartUpload>
    `}async delete(e){this._checkKey(e),this._log("info",`Deleting object ${e}`);let t={[y]:R,[E]:_},s=m(e),{url:r,headers:o}=await this._sign("DELETE",s,{},t,""),i=await this._sendRequest(r,"DELETE",o);return i.status===204||i.status===200}async _sendRequest(e,t,s,r){this._log("info",`Sending ${t} request to ${e}, headers: ${JSON.stringify(s)}`);let o=await fetch(e,{method:t,headers:s,body:r,signal:this.requestAbortTimeout!==void 0?AbortSignal.timeout(this.requestAbortTimeout):void 0});return o.ok||await this._handleErrorResponse(o),o}async _handleErrorResponse(e){let t=await e.text(),s=e.headers.get("x-amz-error-code")||"Unknown",r=e.headers.get("x-amz-error-message")||e.statusText;throw this._log("error",`${h}Request failed with status ${e.status}: ${s} - ${r},err body: ${t}`),new Error(`${h}Request failed with status ${e.status}: ${s} - ${r}, err body: ${t}`)}_buildCanonicalQueryString(e){return Object.keys(e).length<1?"":Object.keys(e).sort().map(t=>`${encodeURIComponent(t)}=${encodeURIComponent(e[t])}`).join("&")}async _getSignatureKey(e){let t=await A(`AWS4${this.secretAccessKey}`,e),s=await A(t,this.region),r=await A(s,K);return A(r,U)}},D=async f=>{let e=z("sha256");return e.update(f),e.digest("hex")},A=async(f,e,t)=>{let s=G("sha256",f);return s.update(e),s.digest(t)},b=f=>{let e=o=>o.replace(/&quot;/g,'"').replace(/&apos;/g,"'").replace(/&lt;/g,"<").replace(/&gt;/g,">").replace(/&amp;/g,"&"),t={},s=/<(\w)([-\w]+)(?:\/|[^>]*>((?:(?!<\1)[\s\S])*)<\/\1\2)>/gm,r;for(;r=s.exec(f);){let[,o,i,a]=r,c=o.toLowerCase()+i,n=a!=null?b(a):!0;typeof n=="string"?t[c]=e(n):Array.isArray(t[c])?t[c].push(n):t[c]=t[c]!=null?[t[c],n]:re[c]?[n]:n}return Object.keys(t).length?t:e(f)};var oe=q;export{q as S3,oe as default};
//# sourceMappingURL=index.min.js.map
