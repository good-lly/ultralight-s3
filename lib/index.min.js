var Q=crypto.createHmac||(await import("node:crypto")).createHmac,Y=crypto.createHash||(await import("node:crypto")).createHash;typeof Q>"u"&&typeof Y>"u"&&console.error("FemtoS3 Module: Crypto functions are not available, please report the issue with necessary description: https://github.com/sentienhq/femtoS3.js/issues");var K="AWS4-HMAC-SHA256",C="aws4_request",P="s3",W="2",_="UNSIGNED-PAYLOAD",X="application/octet-stream",L="application/xml",S="application/json",V=["accessKeyId","secretAccessKey","sessionToken","password"],M=5*1024*1024,y="x-amz-content-sha256",Z="x-amz-date",J="host",k="Authorization",w="Content-Type",T="Content-Length",j="etag",B="last-modified",c="FemtoS3 Module: ",ee=`${c}accessKeyId must be a non-empty string`,te=`${c}secretAccessKey must be a non-empty string`,re=`${c}endpoint must be a non-empty string`,se=`${c}bucketName must be a non-empty string`,g=`${c}key must be a non-empty string`,$=`${c}uploadId must be a non-empty string`,F=`${c}parts must be a non-empty array`,G=`${c}Each part must have a partNumber (number) and ETag (string)`,I=`${c}data must be a Buffer or string`,U=`${c}path must be a string`,q=`${c}prefix must be a string`,z=`${c}maxKeys must be a positive integer`,oe={contents:!0},ne=m=>`%${m.charCodeAt(0).toString(16).toUpperCase()}`,O=m=>encodeURIComponent(m).replace(/[!'()*]/g,ne),f=m=>O(m).replace(/%2F/g,"/"),x=class{constructor({accessKeyId:e,secretAccessKey:t,endpoint:r,bucketName:s,region:o="auto",maxRequestSizeInBytes:i=M,requestAbortTimeout:a=void 0,logger:u=void 0}){this.getBucketName=()=>this.bucketName,this.setBucketName=n=>{this.bucketName=n},this.getRegion=()=>this.region,this.setRegion=n=>{this.region=n},this.getEndpoint=()=>this.endpoint,this.setEndpoint=n=>{this.endpoint=n},this.getMaxRequestSizeInBytes=()=>this.maxRequestSizeInBytes,this.setMaxRequestSizeInBytes=n=>{this.maxRequestSizeInBytes=n},this.getProps=()=>({accessKeyId:this.accessKeyId,secretAccessKey:this.secretAccessKey,region:this.region,bucket:this.bucketName,endpoint:this.endpoint,maxRequestSizeInBytes:this.maxRequestSizeInBytes,requestAbortTimeout:this.requestAbortTimeout,logger:this.logger}),this.setProps=n=>{this._validateConstructorParams(n.accessKeyId,n.secretAccessKey,n.bucketName,n.endpoint),this.accessKeyId=n.accessKeyId,this.secretAccessKey=n.secretAccessKey,this.region=n.region||"auto",this.bucketName=n.bucketName,this.endpoint=n.endpoint,this.maxRequestSizeInBytes=n.maxRequestSizeInBytes||M,this.requestAbortTimeout=n.requestAbortTimeout,this.logger=n.logger},this._validateConstructorParams(e,t,r,s),this.accessKeyId=e,this.secretAccessKey=t,this.endpoint=r,this.bucketName=s,this.region=o,this.maxRequestSizeInBytes=i,this.requestAbortTimeout=a,this.logger=u}_validateConstructorParams(e,t,r,s){if(typeof e!="string"||e.trim().length===0)throw new TypeError(ee);if(typeof t!="string"||t.trim().length===0)throw new TypeError(te);if(typeof r!="string"||r.trim().length===0)throw new TypeError(re);if(typeof s!="string"||s.trim().length===0)throw new TypeError(se)}_log(e,t,r={}){if(this.logger&&typeof this.logger[e]=="function"){let s=a=>typeof a!="object"||a===null?a:Object.keys(a).reduce((u,n)=>(V.includes(n.toLowerCase())?u[n]="[REDACTED]":typeof a[n]=="object"&&a[n]!==null?u[n]=s(a[n]):u[n]=a[n],u),Array.isArray(a)?[]:{}),o=s(r),i={timestamp:new Date().toISOString(),level:e,message:t,...o,context:s({bucketName:this.bucketName,region:this.region,endpoint:this.endpoint,accessKeyId:this.accessKeyId?`${this.accessKeyId.substring(0,4)}...`:void 0})};this.logger[e](i)}}async getContentLength(e){if(typeof e!="string"||e.trim().length===0)throw this._log("error",g),new TypeError(g);let t={[y]:_},r=f(e),{url:s,headers:o}=await this._sign("HEAD",r,{},t,""),a=(await this._sendRequest(s,"HEAD",o)).headers.get(T);return a?parseInt(a,10):0}async bucketExists(){let e={[y]:_},{url:t,headers:r}=await this._sign("HEAD","",{},e,""),s=await this._sendRequest(t,"HEAD",r);return!!(s.ok&&s.status===200)}async fileExists(e){if(typeof e!="string"||e.trim().length===0)throw this._log("error",g),new TypeError(g);let t={[y]:_},r=f(e),{url:s,headers:o}=await this._sign("HEAD",r,{},t,"");try{let i=await fetch(s,{method:"HEAD",headers:o});return i.ok&&i.status===200?!0:(i.status===404||this._handleErrorResponse(i),!1)}catch(i){let a=i instanceof Error?i.message:String(i);throw this._log("error",`${c}Failed to check if file exists: ${a}`),new Error(`${c}Failed to check if file exists: ${a}`)}}async _sign(e,t,r,s,o){let i=new Date().toISOString().replace(/[:-]|\.\d{3}/g,""),a=typeof t=="string"&&t.length>0?new URL(t,this.endpoint):new URL(this.endpoint);a.pathname=`/${encodeURI(this.bucketName)}${a.pathname}`,s[y]=o?await N(o):_,s[Z]=i,s[J]=a.host;let u=this._buildCanonicalHeaders(s),n=Object.keys(s).map(p=>p.toLowerCase()).sort().join(";"),E=await this._buildCanonicalRequest(e,a,r,u,n,o),l=await this._buildStringToSign(i,E),h=await this._calculateSignature(i,l),d=this._buildAuthorizationHeader(i,n,h);return s[k]=d,{url:a.toString(),headers:s}}_buildCanonicalHeaders(e){return Object.entries(e).map(([t,r])=>`${t.toLowerCase()}:${String(r).trim()}`).sort().join(`
`)}async _buildCanonicalRequest(e,t,r,s,o,i){return[e,t.pathname,this._buildCanonicalQueryString(r),`${s}
`,o,i?await N(i):_].join(`
`)}async _buildStringToSign(e,t){let r=[e.slice(0,8),this.region,P,C].join("/");return[K,e,r,await N(t)].join(`
`)}async _calculateSignature(e,t){let r=await this._getSignatureKey(e.slice(0,8));return D(r,t,"hex")}_buildAuthorizationHeader(e,t,r){let s=[e.slice(0,8),this.region,P,C].join("/");return[`${K} Credential=${this.accessKeyId}/${s}`,`SignedHeaders=${t}`,`Signature=${r}`].join(", ")}async list(e="/",t="",r=1e3,s="GET",o={}){if(typeof e!="string"||e.trim().length===0)throw this._log("error",U),new TypeError(U);if(typeof t!="string")throw this._log("error",q),new TypeError(q);if(!Number.isInteger(r)||r<=0)throw this._log("error",z),new TypeError(z);if(s!=="GET"&&s!=="HEAD")throw this._log("error",`${c}method must be either GET or HEAD`),new TypeError(`${c}method must be either GET or HEAD`);if(typeof o!="object")throw this._log("error",`${c}opts must be an object`),new TypeError(`${c}opts must be an object`);this._log("info",`Listing objects in ${e}`);let i={"list-type":W,"max-keys":String(r),...o};t.length>0&&(i.prefix=t);let a={[w]:S,[y]:_},u=e==="/"?e:O(e),{url:n,headers:E}=await this._sign("GET",u,i,a,""),l=`${n}?${new URLSearchParams(i)}`,h=await this._sendRequest(l,"GET",E),d=await h.text();if(s==="HEAD"){let R=h.headers.get(T),A=h.headers.get(B),v=h.headers.get(j);return{size:R?+R:void 0,mtime:A?new Date(A):void 0,ETag:v||void 0}}let p=b(d),H=p.listBucketResult||p.error||p;return H.contents||H}async listMultiPartUploads(e="/",t="",r="GET",s={}){var o,i,a;if(typeof e!="string"||e.trim().length===0)throw this._log("error",U),new TypeError(U);if(typeof t!="string")throw this._log("error",q),new TypeError(q);if(r!=="GET"&&r!=="HEAD")throw this._log("error",`${c}method must be either GET or HEAD`),new TypeError(`${c}method must be either GET or HEAD`);if(typeof s!="object")throw this._log("error",`${c}opts must be an object`),new TypeError(`${c}opts must be an object`);this._log("info",`Listing multipart uploads in ${e}`);let u={uploads:"",...s},n={[w]:S,[y]:_},E=e==="/"?e:O(e),{url:l,headers:h}=await this._sign("GET",E,u,n,""),d=`${l}?${new URLSearchParams(u)}`,p=await this._sendRequest(d,"GET",h),H=await p.text();if(r==="HEAD")return{size:+((o=p.headers.get(T))!==null&&o!==void 0?o:"0"),mtime:new Date((i=p.headers.get(B))!==null&&i!==void 0?i:""),ETag:(a=p.headers.get(j))!==null&&a!==void 0?a:""};let R=b(H),A=R.listMultipartUploadsResult||R.error||R;return A.uploads||A}async get(e,t={}){if(typeof e!="string"||e.trim().length===0)throw this._log("error",g),new TypeError(g);let r={[w]:S,[y]:_};this._log("info",`Getting object ${e}`);let s=f(e),{url:o,headers:i}=await this._sign("GET",s,t,r,"");return(await this._sendRequest(o,"GET",i)).text()}async getStream(e,t=!0,r=0,s=this.maxRequestSizeInBytes,o={}){let i=t?o:{partNumber:r,...o},a={[w]:S,[y]:_,...t?{}:{range:`bytes=${r*s}-${(r+1)*s-1}`}},u=f(e),{url:n,headers:E}=await this._sign("GET",u,i,a,""),l=`${n}?${new URLSearchParams(i)}`;return(await this._sendRequest(l,"GET",E)).body}async put(e,t){if(typeof e!="string"||e.trim().length===0)throw this._log("error",g),new TypeError(g);if(!(t instanceof Buffer||typeof t=="string"))throw this._log("error",I),new TypeError(I);this._log("info",`Uploading object ${e}`);let r=typeof t=="string"?Buffer.byteLength(t):t.length,s={[T]:r},o=f(e),{url:i,headers:a}=await this._sign("PUT",o,{},s,t);return await this._sendRequest(i,"PUT",a,t)}async getMultipartUploadId(e,t=X){if(typeof e!="string"||e.trim().length===0)throw this._log("error",g),new TypeError(g);if(typeof t!="string")throw this._log("error",`${c}fileType must be a string`),new TypeError(`${c}fileType must be a string`);this._log("info",`Initiating multipart upload for object ${e}`);let r={uploads:""},s={[w]:t,[y]:_},o=f(e),{url:i,headers:a}=await this._sign("POST",o,r,s,""),u=`${i}?${new URLSearchParams(r)}`,E=await(await this._sendRequest(u,"POST",a)).text(),l=b(E);if(typeof l=="object"&&l!==null&&"error"in l&&typeof l.error=="object"&&l.error!==null&&"message"in l.error){let h=String(l.error.message);throw this._log("error",`${c}Failed to abort multipart upload: ${h}`),new Error(`${c}Failed to abort multipart upload: ${h}`)}if(typeof l=="object"&&l!==null){if(!l.initiateMultipartUploadResult||!l.initiateMultipartUploadResult.uploadId)throw this._log("error",`${c}Failed to create multipart upload: no uploadId in response`),new Error(`${c}Failed to create multipart upload: Missing upload ID in response`);return l.initiateMultipartUploadResult.uploadId}else throw this._log("error",`${c}Failed to create multipart upload: unexpected response format`),new Error(`${c}Failed to create multipart upload: Unexpected response format`)}async uploadPart(e,t,r,s,o={}){this._validateUploadPartParams(e,t,r,s,o);let i={uploadId:r,partNumber:s,...o},a={[T]:t.length},u=f(e),{url:n,headers:E}=await this._sign("PUT",u,i,a,t),l=`${n}?${new URLSearchParams(i)}`,d=(await this._sendRequest(l,"PUT",E,t)).headers.get("etag")||"";return{partNumber:s,ETag:d}}_validateUploadPartParams(e,t,r,s,o){if(typeof e!="string"||e.trim().length===0)throw this._log("error",g),new TypeError(g);if(!(t instanceof Buffer||typeof t=="string"))throw this._log("error",I),new TypeError(I);if(typeof r!="string"||r.trim().length===0)throw this._log("error",$),new TypeError($);if(!Number.isInteger(s)||s<=0)throw this._log("error",`${c}partNumber must be a positive integer`),new TypeError(`${c}partNumber must be a positive integer`);if(typeof o!="object")throw this._log("error",`${c}opts must be an object`),new TypeError(`${c}opts must be an object`)}async completeMultipartUpload(e,t,r){if(typeof e!="string"||e.trim().length===0)throw this._log("error",g),new TypeError(g);if(typeof t!="string"||t.trim().length===0)throw this._log("error",$),new TypeError($);if(!Array.isArray(r)||r.length===0)throw this._log("error",F),new TypeError(F);if(!r.every(p=>typeof p.partNumber=="number"&&typeof p.ETag=="string"))throw this._log("error",G),new TypeError(G);this._log("info",`Complete multipart upload ${t} for object ${e}`);let s={uploadId:t},o=this._buildCompleteMultipartUploadXml(r),i={[w]:L,[T]:Buffer.byteLength(o).toString(),[y]:await N(o)},a=f(e),{url:u,headers:n}=await this._sign("POST",a,s,i,o),E=`${u}?${new URLSearchParams(s)}`,h=await(await this._sendRequest(E,"POST",n,o)).text(),d=b(h);if(typeof d=="object"&&d!==null&&"error"in d&&typeof d.error=="object"&&d.error!==null&&"message"in d.error){let p=String(d.error.message);throw this._log("error",`${c}Failed to abort multipart upload: ${p}`),new Error(`${c}Failed to abort multipart upload: ${p}`)}return d.completeMultipartUploadResult}async abortMultipartUpload(e,t){if(typeof e!="string"||e.trim().length===0)throw this._log("error",g),new TypeError(g);if(typeof t!="string"||t.trim().length===0)throw this._log("error",$),new TypeError($);this._log("info",`Aborting multipart upload ${t} for object ${e}`);let r={uploadId:t},s={[w]:L,[y]:_};try{let o=f(e),{url:i,headers:a}=await this._sign("DELETE",o,r,s,""),u=`${i}?${new URLSearchParams(r)}`,n=await this._sendRequest(u,"DELETE",a);if(n.ok){let E=await n.text(),l=b(E);if(typeof l=="object"&&l!==null&&"error"in l&&typeof l.error=="object"&&l.error!==null&&"message"in l.error){let h=String(l.error.message);throw this._log("error",`${c}Failed to abort multipart upload: ${h}`),new Error(`${c}Failed to abort multipart upload: ${h}`)}return{status:"Aborted",key:e,uploadId:t,response:l}}else throw this._log("error",`${c}Abort request failed with status ${n.status}`),new Error(`${c}Abort request failed with status ${n.status}`)}catch(o){let i=o instanceof Error?o.message:String(o);throw this._log("error",`${c}Failed to abort multipart upload for key ${e}: ${i}`),new Error(`${c}Failed to abort multipart upload for key ${e}: ${i}`)}}_buildCompleteMultipartUploadXml(e){return`
      <CompleteMultipartUpload>
        ${e.map(t=>`
          <Part>
            <PartNumber>${t.partNumber}</PartNumber>
            <ETag>${t.ETag}</ETag>
          </Part>
        `).join("")}
      </CompleteMultipartUpload>
    `}async delete(e){if(typeof e!="string"||e.trim().length===0)throw this._log("error",g),new TypeError(g);this._log("info",`Deleting object ${e}`);let t={[w]:S,[y]:_},r=f(e),{url:s,headers:o}=await this._sign("DELETE",r,{},t,"");return(await this._sendRequest(s,"DELETE",o)).text()}async _sendRequest(e,t,r,s){this._log("info",`Sending ${t} request to ${e}, headers: ${JSON.stringify(r)}`);let o=await fetch(e,{method:t,headers:r,body:s,signal:this.requestAbortTimeout!==void 0?AbortSignal.timeout(this.requestAbortTimeout):void 0});return o.ok||await this._handleErrorResponse(o),o}async _handleErrorResponse(e){let t=await e.text(),r=e.headers.get("x-amz-error-code")||"Unknown",s=e.headers.get("x-amz-error-message")||e.statusText;throw this._log("error",`${c}Request failed with status ${e.status}: ${r} - ${s},err body: ${t}`),new Error(`${c}Request failed with status ${e.status}: ${r} - ${s}, err body: ${t}`)}_buildCanonicalQueryString(e){return Object.keys(e).length<1?"":Object.keys(e).sort().map(t=>`${encodeURIComponent(t)}=${encodeURIComponent(e[t])}`).join("&")}async _getSignatureKey(e){let t=await D(`AWS4${this.secretAccessKey}`,e),r=await D(t,this.region),s=await D(r,P);return D(s,C)}},N=async m=>{let e=Y("sha256");return e.update(m),e.digest("hex")},D=async(m,e,t)=>{let r=Q("sha256",m);return r.update(e),r.digest(t)},b=m=>{let e=o=>o.replace(/&quot;/g,'"').replace(/&apos;/g,"'").replace(/&lt;/g,"<").replace(/&gt;/g,">").replace(/&amp;/g,"&"),t={},r=/<(\w)([-\w]+)(?:\/|[^>]*>((?:(?!<\1)[\s\S])*)<\/\1\2)>/gm,s;for(;s=r.exec(m);){let[,o,i,a]=s,u=o.toLowerCase()+i,n=a!=null?b(a):!0;typeof n=="string"?t[u]=e(n):Array.isArray(t[u])?t[u].push(n):t[u]=t[u]!=null?[t[u],n]:oe[u]?[n]:n}return Object.keys(t).length?t:e(m)};var ie=x;export{x as S3,ie as default};
//# sourceMappingURL=index.min.js.map
