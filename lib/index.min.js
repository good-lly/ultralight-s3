var N="AWS4-HMAC-SHA256",K="aws4_request",O="s3",v="2",f="UNSIGNED-PAYLOAD",W="application/octet-stream",q="application/xml",w="application/json",X=["accessKeyId","secretAccessKey","sessionToken","password"];var E="x-amz-content-sha256",Z="x-amz-date",V="host",J="Authorization",m="Content-Type",R="Content-Length",P="etag",M="last-modified",u="ultralight-s3 Module: ",ee=`${u}accessKeyId must be a non-empty string`,te=`${u}secretAccessKey must be a non-empty string`,se=`${u}endpoint must be a non-empty string`,re=`${u}bucketName must be a non-empty string`,L=`${u}key must be a non-empty string`,$=`${u}uploadId must be a non-empty string`,j=`${u}parts must be a non-empty array`,k=`${u}Each part must have a partNumber (number) and ETag (string)`,U=`${u}data must be a Buffer or string`,B=`${u}prefix must be a string`,F=`${u}maxKeys must be a positive integer`,G=`${u}delimiter must be a string`,z=crypto.createHmac||(await import("node:crypto")).createHmac,Q=crypto.createHash||(await import("node:crypto")).createHash;typeof z>"u"&&typeof Q>"u"&&console.error("ultralight-S3 Module: Crypto functions are not available, please report the issue with necessary description: https://github.com/sentienhq/ultralight-s3/issues");var ne={contents:!0},oe=p=>`%${p.charCodeAt(0).toString(16).toUpperCase()}`,C=p=>encodeURIComponent(p).replace(/[!'()*]/g,oe),y=p=>C(p).replace(/%2F/g,"/"),x=class{constructor({accessKeyId:e,secretAccessKey:t,endpoint:r,bucketName:n,region:o="auto",maxRequestSizeInBytes:i=5242880,requestAbortTimeout:a=void 0,logger:c=void 0}){this.getBucketName=()=>this.bucketName,this.setBucketName=s=>{this.bucketName=s},this.getRegion=()=>this.region,this.setRegion=s=>{this.region=s},this.getEndpoint=()=>this.endpoint,this.setEndpoint=s=>{this.endpoint=s},this.getMaxRequestSizeInBytes=()=>this.maxRequestSizeInBytes,this.setMaxRequestSizeInBytes=s=>{this.maxRequestSizeInBytes=s},this.sanitizeETag=s=>I(s),this.getProps=()=>({accessKeyId:this.accessKeyId,secretAccessKey:this.secretAccessKey,region:this.region,bucket:this.bucketName,endpoint:this.endpoint,maxRequestSizeInBytes:this.maxRequestSizeInBytes,requestAbortTimeout:this.requestAbortTimeout,logger:this.logger}),this.setProps=s=>{this._validateConstructorParams(s.accessKeyId,s.secretAccessKey,s.bucketName,s.endpoint),this.accessKeyId=s.accessKeyId,this.secretAccessKey=s.secretAccessKey,this.region=s.region||"auto",this.bucketName=s.bucketName,this.endpoint=s.endpoint,this.maxRequestSizeInBytes=s.maxRequestSizeInBytes||5242880,this.requestAbortTimeout=s.requestAbortTimeout,this.logger=s.logger},this._validateConstructorParams(e,t,r,n),this.accessKeyId=e,this.secretAccessKey=t,this.endpoint=r,this.bucketName=n,this.region=o,this.maxRequestSizeInBytes=i,this.requestAbortTimeout=a,this.logger=c}_validateConstructorParams(e,t,r,n){if(typeof e!="string"||e.trim().length===0)throw new TypeError(ee);if(typeof t!="string"||t.trim().length===0)throw new TypeError(te);if(typeof r!="string"||r.trim().length===0)throw new TypeError(se);if(typeof n!="string"||n.trim().length===0)throw new TypeError(re)}_checkMethodHeadnGet(e){if(e!=="GET"&&e!=="HEAD")throw this._log("error",`${u}method must be either GET or HEAD`),new Error("method must be either GET or HEAD")}_checkKey(e){if(typeof e!="string"||e.trim().length===0)throw this._log("error",L),new TypeError(L)}_checkDelimiter(e){if(typeof e!="string"||e.trim().length===0)throw this._log("error",G),new TypeError(G)}_checkPrefix(e){if(typeof e!="string")throw this._log("error",B),new TypeError(B)}_checkMaxKeys(e){if(typeof e!="number"||e<=0)throw this._log("error",F),new TypeError(F)}_checkOpts(e){if(typeof e!="object")throw this._log("error",`${u}opts must be an object`),new TypeError(`${u}opts must be an object`)}_log(e,t,r={}){if(this.logger&&typeof this.logger[e]=="function"){let n=a=>typeof a!="object"||a===null?a:Object.keys(a).reduce((c,s)=>(X.includes(s.toLowerCase())?c[s]="[REDACTED]":typeof a[s]=="object"&&a[s]!==null?c[s]=n(a[s]):c[s]=a[s],c),Array.isArray(a)?[]:{}),o=n(r),i={timestamp:new Date().toISOString(),level:e,message:t,...o,context:n({bucketName:this.bucketName,region:this.region,endpoint:this.endpoint,accessKeyId:this.accessKeyId?`${this.accessKeyId.substring(0,4)}...`:void 0})};this.logger[e](i)}}async getContentLength(e){this._checkKey(e);let t={[E]:f},r=y(e),{url:n,headers:o}=await this._sign("HEAD",r,{},t,""),a=(await this._sendRequest(n,"HEAD",o)).headers.get(R);return a?parseInt(a,10):0}async bucketExists(){let e={[E]:f},{url:t,headers:r}=await this._sign("HEAD","",{},e,""),n=await this._sendRequest(t,"HEAD",r,"",[200,404,403]);return this._log("error",`Response status: ${n.status,n.statusText}`),!!(n.ok&&n.status===200)}async createBucket(){let e=`
    <CreateBucketConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/">
      <LocationConstraint>${this.region}</LocationConstraint>
    </CreateBucketConfiguration>
    `,t={[m]:q,[R]:Buffer.byteLength(e).toString(),[E]:await A(e)},r=encodeURI(""),{url:n,headers:o}=await this._sign("PUT",r,{},t,""),i=await this._sendRequest(n,"PUT",o,e,[200,404,403]);return!!(i.ok&&i.status===200)}async fileExists(e,t={}){this._checkKey(e);let{filteredOpts:r,conditionalHeaders:n}=this._filterIfHeaders(t),o={[E]:f,...n},i=y(e),{url:a,headers:c}=await this._sign("HEAD",i,r,o,"");try{let s=await this._sendRequest(a,"HEAD",c,"",[200,404,412,304]);return s.status===404?!1:s.status===412||s.status===304?null:s.ok&&s.status===200?!0:(this._handleErrorResponse(s),!1)}catch(s){let l=s instanceof Error?s.message:String(s);throw this._log("error",`${u}Failed to check if file exists: ${l}`),new Error(`${u}Failed to check if file exists: ${l}`)}}async _sign(e,t,r={},n,o){let i=new Date().toISOString().replace(/[:-]|\.\d{3}/g,""),a=typeof t=="string"&&t.length>0?new URL(t,this.endpoint):new URL(this.endpoint);a.pathname=`/${encodeURI(this.bucketName)}${a.pathname}`,n[E]=o?await A(o):f,n[Z]=i,n[V]=a.host;let c=this._buildCanonicalHeaders(n),s=Object.keys(n).map(_=>_.toLowerCase()).sort().join(";"),l=await this._buildCanonicalRequest(e,a,r,c,s,o),h=await this._buildStringToSign(i,l),d=await this._calculateSignature(i,h),g=this._buildAuthorizationHeader(i,s,d);return n[J]=g,{url:a.toString(),headers:n}}_buildCanonicalHeaders(e){return Object.entries(e).map(([t,r])=>`${t.toLowerCase()}:${String(r).trim()}`).sort().join(`
`)}async _buildCanonicalRequest(e,t,r,n,o,i){return[e,t.pathname,this._buildCanonicalQueryString(r),`${n}
`,o,i?await A(i):f].join(`
`)}async _buildStringToSign(e,t){let r=[e.slice(0,8),this.region,O,K].join("/");return[N,e,r,await A(t)].join(`
`)}async _calculateSignature(e,t){let r=await this._getSignatureKey(e.slice(0,8));return H(r,t,"hex")}_buildAuthorizationHeader(e,t,r){let n=[e.slice(0,8),this.region,O,K].join("/");return[`${N} Credential=${this.accessKeyId}/${n}`,`SignedHeaders=${t}`,`Signature=${r}`].join(", ")}_filterIfHeaders(e){let t={},r={},n=["if-match","if-none-match","if-modified-since","if-unmodified-since"];for(let[o,i]of Object.entries(e))n.includes(o)?r[o]=i:t[o]=i;return{filteredOpts:t,conditionalHeaders:r}}async list(e="/",t="",r=1e3,n="GET",o={}){this._checkDelimiter(e),this._checkPrefix(t),this._checkMaxKeys(r),this._checkMethodHeadnGet(n),this._checkOpts(o),this._log("info",`Listing objects in ${t}`);let i={"list-type":v,"max-keys":String(r),...o};t.length>0&&(i.prefix=t);let a={[m]:w,[E]:f},c=e==="/"?e:C(e),{url:s,headers:l}=await this._sign("GET",c,i,a,""),h=`${s}?${new URLSearchParams(i)}`,d=await this._sendRequest(h,"GET",l),g=await d.text();if(n==="HEAD"){let T=d.headers.get(R),S=d.headers.get(M),Y=d.headers.get(P);return{size:T?+T:void 0,mtime:S?new Date(S):void 0,ETag:Y||void 0}}let _=b(g),D=_.listBucketResult||_.error||_;return D.contents||D}async listMultiPartUploads(e="/",t="",r="GET",n={}){var o,i,a;this._checkDelimiter(e),this._checkPrefix(t),this._checkMethodHeadnGet(r),this._checkOpts(n),this._log("info",`Listing multipart uploads in ${t}`);let c={uploads:"",...n},s={[m]:w,[E]:f},l=e==="/"?e:C(e),{url:h,headers:d}=await this._sign("GET",l,c,s,""),g=`${h}?${new URLSearchParams(c)}`,_=await this._sendRequest(g,"GET",d),D=await _.text();if(r==="HEAD")return{size:+((o=_.headers.get(R))!==null&&o!==void 0?o:"0"),mtime:new Date((i=_.headers.get(M))!==null&&i!==void 0?i:""),ETag:(a=_.headers.get(P))!==null&&a!==void 0?a:""};let T=b(D),S=T.listMultipartUploadsResult||T.error||T;return S.uploads||S}async get(e,t={}){this._checkKey(e),this._log("info",`Getting object ${e}`);let{filteredOpts:r,conditionalHeaders:n}=this._filterIfHeaders(t),o={[m]:w,[E]:f,...n},i=y(e),{url:a,headers:c}=await this._sign("GET",i,r,o,""),s=await this._sendRequest(a,"GET",c,"",[200,404,412,304]);if(s.status===404||s.status===412||s.status===304)return this._log("error",`Failed to get object. Status: ${s.status}`),null;if(!s.ok)throw this._log("error",`Failed to get object. Status: ${s.status}`),new Error(`Failed to get object. Status: ${s.status}`);return s}async getObjectWithETag(e,t={}){this._checkKey(e),this._log("info",`Getting object ${e}`);let{filteredOpts:r,conditionalHeaders:n}=this._filterIfHeaders(t),o={[m]:w,[E]:f,...n},i=y(e),{url:a,headers:c}=await this._sign("GET",i,r,o,"");try{let s=await this._sendRequest(a,"GET",c,"",[200,404,412,304]);if(s.status===404||s.status===412||s.status===304)return this._log("error",`Failed to get object. Status: ${s.status}`),{etag:null,data:null};if(!s.ok)throw this._log("error",`Failed to get object. Status: ${s.status}`),new Error(`Failed to get object. Status: ${s.status}`);let l=s.headers.get("etag");if(!l)throw new Error("ETag not found in response headers");let h=await s.text();return{etag:I(l),data:h}}catch(s){throw this._log("error",`Error getting object ${e} with ETag: ${s}`),s}}async getEtag(e,t={}){this._checkKey(e),this._log("info",`Getting etag object ${e}`);let{filteredOpts:r,conditionalHeaders:n}=this._filterIfHeaders(t),o={[m]:w,[E]:f,...n},i=y(e),{url:a,headers:c}=await this._sign("HEAD",i,r,o,""),s=await this._sendRequest(a,"HEAD",c,"",[200,412,304]);if(this._log("info",`Response status: ${s.status,s.statusText}`),s.status===412||s.status===304)return null;let l=s.headers.get("etag");if(!l)throw this._log("error","ETag not found in response headers"),new Error("ETag not found in response headers");return I(l)}async getResponse(e,t=!0,r=0,n=this.maxRequestSizeInBytes,o={}){this._checkKey(e);let{filteredOpts:i,conditionalHeaders:a}=this._filterIfHeaders({...o}),c={[m]:w,[E]:f,...t?{}:{range:`bytes=${r}-${n-1}`},...a},s=y(e),{url:l,headers:h}=await this._sign("GET",s,i,c,""),d=`${l}?${new URLSearchParams(i)}`;return this._sendRequest(d,"GET",h)}async put(e,t){if(this._checkKey(e),!(t instanceof Buffer||typeof t=="string"))throw this._log("error",U),new TypeError(U);this._log("info",`Uploading object ${e}`);let r=typeof t=="string"?Buffer.byteLength(t):t.length,n={[R]:r},o=y(e),{url:i,headers:a}=await this._sign("PUT",o,{},n,t);return this._sendRequest(i,"PUT",a,t,[200])}async getMultipartUploadId(e,t=W){if(this._checkKey(e),typeof t!="string")throw this._log("error",`${u}fileType must be a string`),new TypeError(`${u}fileType must be a string`);this._log("info",`Initiating multipart upload for object ${e}`);let r={uploads:""},n={[m]:t,[E]:f},o=y(e),{url:i,headers:a}=await this._sign("POST",o,r,n,""),c=`${i}?${new URLSearchParams(r)}`,l=await(await this._sendRequest(c,"POST",a)).text(),h=b(l);if(typeof h=="object"&&h!==null&&"error"in h&&typeof h.error=="object"&&h.error!==null&&"message"in h.error){let d=String(h.error.message);throw this._log("error",`${u}Failed to abort multipart upload: ${d}`),new Error(`${u}Failed to abort multipart upload: ${d}`)}if(typeof h=="object"&&h!==null){if(!h.initiateMultipartUploadResult||!h.initiateMultipartUploadResult.uploadId)throw this._log("error",`${u}Failed to create multipart upload: no uploadId in response`),new Error(`${u}Failed to create multipart upload: Missing upload ID in response`);return h.initiateMultipartUploadResult.uploadId}else throw this._log("error",`${u}Failed to create multipart upload: unexpected response format`),new Error(`${u}Failed to create multipart upload: Unexpected response format`)}async uploadPart(e,t,r,n,o={}){this._validateUploadPartParams(e,t,r,n,o);let i={uploadId:r,partNumber:n,...o},a={[R]:t.length},c=y(e),{url:s,headers:l}=await this._sign("PUT",c,i,a,t),h=`${s}?${new URLSearchParams(i)}`,d=await this._sendRequest(h,"PUT",l,t),g=I(d.headers.get("etag")||"");return{partNumber:n,ETag:g}}_validateUploadPartParams(e,t,r,n,o){if(this._checkKey(e),!(t instanceof Buffer||typeof t=="string"))throw this._log("error",U),new TypeError(U);if(typeof r!="string"||r.trim().length===0)throw this._log("error",$),new TypeError($);if(!Number.isInteger(n)||n<=0)throw this._log("error",`${u}partNumber must be a positive integer`),new TypeError(`${u}partNumber must be a positive integer`);this._checkOpts(o)}async completeMultipartUpload(e,t,r){if(this._checkKey(e),typeof t!="string"||t.trim().length===0)throw this._log("error",$),new TypeError($);if(!Array.isArray(r)||r.length===0)throw this._log("error",j),new TypeError(j);if(!r.every(_=>typeof _.partNumber=="number"&&typeof _.ETag=="string"))throw this._log("error",k),new TypeError(k);this._log("info",`Complete multipart upload ${t} for object ${e}`);let n={uploadId:t},o=this._buildCompleteMultipartUploadXml(r),i={[m]:q,[R]:Buffer.byteLength(o).toString(),[E]:await A(o)},a=y(e),{url:c,headers:s}=await this._sign("POST",a,n,i,o),l=`${c}?${new URLSearchParams(n)}`,d=await(await this._sendRequest(l,"POST",s,o)).text(),g=b(d);if(typeof g=="object"&&g!==null&&"error"in g&&typeof g.error=="object"&&g.error!==null&&"message"in g.error){let _=String(g.error.message);throw this._log("error",`${u}Failed to abort multipart upload: ${_}`),new Error(`${u}Failed to abort multipart upload: ${_}`)}return g.completeMultipartUploadResult}async abortMultipartUpload(e,t){if(this._checkKey(e),typeof t!="string"||t.trim().length===0)throw this._log("error",$),new TypeError($);this._log("info",`Aborting multipart upload ${t} for object ${e}`);let r={uploadId:t},n={[m]:q,[E]:f};try{let o=y(e),{url:i,headers:a}=await this._sign("DELETE",o,r,n,""),c=`${i}?${new URLSearchParams(r)}`,s=await this._sendRequest(c,"DELETE",a);if(s.ok){let l=await s.text(),h=b(l);if(typeof h=="object"&&h!==null&&"error"in h&&typeof h.error=="object"&&h.error!==null&&"message"in h.error){let d=String(h.error.message);throw this._log("error",`${u}Failed to abort multipart upload: ${d}`),new Error(`${u}Failed to abort multipart upload: ${d}`)}return{status:"Aborted",key:e,uploadId:t,response:h}}else throw this._log("error",`${u}Abort request failed with status ${s.status}`),new Error(`${u}Abort request failed with status ${s.status}`)}catch(o){let i=o instanceof Error?o.message:String(o);throw this._log("error",`${u}Failed to abort multipart upload for key ${e}: ${i}`),new Error(`${u}Failed to abort multipart upload for key ${e}: ${i}`)}}_buildCompleteMultipartUploadXml(e){return`
      <CompleteMultipartUpload>
        ${e.map(t=>`
          <Part>
            <PartNumber>${t.partNumber}</PartNumber>
            <ETag>${t.ETag}</ETag>
          </Part>
        `).join("")}
      </CompleteMultipartUpload>
    `}async delete(e){this._checkKey(e),this._log("info",`Deleting object ${e}`);let t={[m]:w,[E]:f},r=y(e),{url:n,headers:o}=await this._sign("DELETE",r,{},t,""),i=await this._sendRequest(n,"DELETE",o);return i.status===204||i.status===200}async _sendRequest(e,t,r,n,o=[]){this._log("info",`Sending ${t} request to ${e}, headers: ${JSON.stringify(r)}`);let i=await fetch(e,{method:t,headers:r,body:["GET","HEAD"].includes(t)?void 0:n,signal:this.requestAbortTimeout!==void 0?AbortSignal.timeout(this.requestAbortTimeout):void 0});return this._log("info",`Response status: ${i.status,o}`),!i.ok&&!o.includes(i.status)&&await this._handleErrorResponse(i),i}async _handleErrorResponse(e){let t=await e.text(),r=e.headers.get("x-amz-error-code")||"Unknown",n=e.headers.get("x-amz-error-message")||e.statusText;throw this._log("error",`${u}Request failed with status ${e.status}: ${r} - ${n},err body: ${t}`),new Error(`${u}Request failed with status ${e.status}: ${r} - ${n}, err body: ${t}`)}_buildCanonicalQueryString(e){return Object.keys(e).length<1?"":Object.keys(e).sort().map(t=>`${encodeURIComponent(t)}=${encodeURIComponent(e[t])}`).join("&")}async _getSignatureKey(e){let t=await H(`AWS4${this.secretAccessKey}`,e),r=await H(t,this.region),n=await H(r,O);return H(n,K)}},A=async p=>{let e=Q("sha256");return e.update(p),e.digest("hex")},H=async(p,e,t)=>{let r=z("sha256",p);return r.update(e),r.digest(t)},I=p=>{let e={'"':"","&quot;":"","&#34;":"","&QUOT;":"","&#x00022":""};return p.replace(/^("|&quot;|&#34;)|("|&quot;|&#34;)$/g,t=>e[t])},b=p=>{let e=o=>o.replace(/&quot;/g,'"').replace(/&apos;/g,"'").replace(/&lt;/g,"<").replace(/&gt;/g,">").replace(/&amp;/g,"&"),t={},r=/<(\w)([-\w]+)(?:\/|[^>]*>((?:(?!<\1)[\s\S])*)<\/\1\2)>/gm,n;for(;n=r.exec(p);){let[,o,i,a]=n,c=o.toLowerCase()+i,s=a!=null?b(a):!0;typeof s=="string"?t[c]=I(e(s)):Array.isArray(t[c])?t[c].push(s):t[c]=t[c]!=null?[t[c],s]:ne[c]?[s]:s}return Object.keys(t).length?t:e(p)};var ie=x;export{x as S3,ie as default,I as sanitizeETag};
//# sourceMappingURL=index.min.js.map
