{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["'use strict';\n\n// Constants\nconst AWS_ALGORITHM = 'AWS4-HMAC-SHA256';\nconst AWS_REQUEST_TYPE = 'aws4_request';\nconst S3_SERVICE = 's3';\nconst LIST_TYPE = '2';\nconst UNSIGNED_PAYLOAD = 'UNSIGNED-PAYLOAD';\nconst DEFAULT_STREAM_CONTENT_TYPE = 'application/octet-stream';\nconst XML_CONTENT_TYPE = 'application/xml';\nconst JSON_CONTENT_TYPE = 'application/json';\n// List of keys that might contain sensitive information\nconst SENSITIVE_KEYS_REDACTED = ['accessKeyId', 'secretAccessKey', 'sessionToken', 'password'];\nconst MIN_MAX_REQUEST_SIZE_IN_BYTES = 5 * 1024 * 1024;\n\n// Headers\nconst HEADER_AMZ_CONTENT_SHA256 = 'x-amz-content-sha256';\nconst HEADER_AMZ_DATE = 'x-amz-date';\nconst HEADER_HOST = 'host';\nconst HEADER_AUTHORIZATION = 'Authorization';\nconst HEADER_CONTENT_TYPE = 'Content-Type';\nconst HEADER_CONTENT_LENGTH = 'Content-Length';\nconst HEADER_ETAG = 'etag';\nconst HEADER_LAST_MODIFIED = 'last-modified';\n\n// Error messages\nconst ERROR_PREFIX = 'ultralight-s3 Module: ';\nconst ERROR_ACCESS_KEY_REQUIRED = `${ERROR_PREFIX}accessKeyId must be a non-empty string`;\nconst ERROR_SECRET_KEY_REQUIRED = `${ERROR_PREFIX}secretAccessKey must be a non-empty string`;\nconst ERROR_ENDPOINT_REQUIRED = `${ERROR_PREFIX}endpoint must be a non-empty string`;\nconst ERROR_BUCKET_NAME_REQUIRED = `${ERROR_PREFIX}bucketName must be a non-empty string`;\nconst ERROR_KEY_REQUIRED = `${ERROR_PREFIX}key must be a non-empty string`;\nconst ERROR_UPLOAD_ID_REQUIRED = `${ERROR_PREFIX}uploadId must be a non-empty string`;\nconst ERROR_PARTS_REQUIRED = `${ERROR_PREFIX}parts must be a non-empty array`;\nconst ERROR_INVALID_PART = `${ERROR_PREFIX}Each part must have a partNumber (number) and ETag (string)`;\nconst ERROR_DATA_BUFFER_REQUIRED = `${ERROR_PREFIX}data must be a Buffer or string`;\n// const ERROR_PATH_REQUIRED = `${ERROR_PREFIX}path must be a string`;\nconst ERROR_PREFIX_TYPE = `${ERROR_PREFIX}prefix must be a string`;\nconst ERROR_MAX_KEYS_TYPE = `${ERROR_PREFIX}maxKeys must be a positive integer`;\nconst ERROR_DELIMITER_REQUIRED = `${ERROR_PREFIX}delimiter must be a string`;\n\nconst STATUS_CODES: Record<string, string> = {\n  '200': 'OK',\n  '204': 'No Content',\n  '205': 'Reset Content',\n  '206': 'Partial Content',\n  '301': 'Moved Permanently',\n  '302': 'Found',\n  '400': 'Bad Request',\n  '401': 'Unauthorized',\n  '403': 'Forbidden',\n  '404': 'Not Found',\n  '418': \"I'm a Teapot\",\n  '428': 'Precondition Required',\n  '429': 'Too Many Requests',\n  '500': 'Internal Server Error',\n  '501': 'Not Implemented',\n};\n\ninterface S3Config {\n  accessKeyId: string;\n  secretAccessKey: string;\n  endpoint: string;\n  bucketName: string;\n  region?: string;\n  maxRequestSizeInBytes?: number;\n  requestAbortTimeout?: number;\n  logger?: Logger;\n}\n\ndeclare global {\n  interface Crypto {\n    createHmac: (\n      algorithm: string,\n      key: string | Buffer,\n    ) => {\n      update: (data: string | Buffer) => void;\n      digest: (encoding?: 'hex' | 'base64' | 'latin1') => string;\n    };\n    createHash: (algorithm: string) => {\n      update: (data: string | Buffer) => void;\n      digest: (encoding?: 'hex' | 'base64' | 'latin1') => string;\n    };\n  }\n}\n\ninterface Logger {\n  info: (message: string, ...args: any[]) => void;\n  warn: (message: string, ...args: any[]) => void;\n  error: (message: string, ...args: any[]) => void;\n}\n\ninterface UploadPart {\n  partNumber: number;\n  ETag: string;\n}\n\ninterface CompleteMultipartUploadResult {\n  Location: string;\n  Bucket: string;\n  Key: string;\n  ETag: string;\n}\n\ntype HttpMethod = 'POST' | 'GET' | 'HEAD' | 'PUT' | 'DELETE';\n\nlet _createHmac = crypto.createHmac || (await import('node:crypto')).createHmac;\nlet _createHash = crypto.createHash || (await import('node:crypto')).createHash;\n\nif (typeof _createHmac === 'undefined' && typeof _createHash === 'undefined') {\n  console.error(\n    'ultralight-S3 Module: Crypto functions are not available, please report the issue with necessary description: https://github.com/sentienhq/ultralight-s3/issues',\n  );\n}\n\nconst expectArray: { [key: string]: boolean } = {\n  contents: true,\n};\n\nconst encodeAsHex = (c: string): string => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;\n\nconst uriEscape = (uriStr: string): string => {\n  return encodeURIComponent(uriStr).replace(/[!'()*]/g, encodeAsHex);\n};\n\nconst uriResourceEscape = (string: string): string => {\n  return uriEscape(string).replace(/%2F/g, '/');\n};\n\n/**\n * S3 class for interacting with S3-compatible object storage services.\n * This class provides methods for common S3 operations such as uploading, downloading,\n * and deleting objects, as well as multipart uploads.\n *\n * @class\n * @example\n * const s3 = new S3({\n *   accessKeyId: 'your-access-key',\n *   secretAccessKey: 'your-secret-key',\n *   endpoint: 'https://your-s3-endpoint.com',\n *   bucketName: 'your-bucket-name',\n *   region: 'us-east-1' // by default is auto\n * });\n *\n * // Upload a file\n * await s3.put('example.txt', 'Hello, World!');\n *\n * // Download a file\n * const content = await s3.get('example.txt');\n *\n * // Delete a file\n * await s3.delete('example.txt');\n */\nclass S3 {\n  /**\n   * Creates an instance of the S3 class.\n   *\n   * @constructor\n   * @param {Object} config - Configuration options for the S3 instance.\n   * @param {string} config.accessKeyId - The access key ID for authentication.\n   * @param {string} config.secretAccessKey - The secret access key for authentication.\n   * @param {string} config.endpoint - The endpoint URL of the S3-compatible service.\n   * @param {string} [config.bucketName=''] - The name of the bucket to operate on.\n   * @param {string} [config.region='auto'] - The region of the S3 service.\n   * @param {number} [config.maxRequestSizeInBytes=5242880] - The maximum size of a single request in bytes (minimum for AWS S3 is 5MB).\n   * @param {number} [config.requestAbortTimeout=undefined] - The timeout in milliseconds after which a request should be aborted (careful on streamed requests).\n   * @param {Object} [config.logger=null] - A logger object with methods like info, warn, error.\n   * @throws {TypeError} Will throw an error if required parameters are missing or of incorrect type.\n   */\n  private accessKeyId: string;\n  private secretAccessKey: string;\n  private endpoint: string;\n  private bucketName: string;\n  private region: string;\n  private maxRequestSizeInBytes: number;\n  private requestAbortTimeout?: number;\n  private logger?: Logger;\n\n  constructor({\n    accessKeyId,\n    secretAccessKey,\n    endpoint,\n    bucketName,\n    region = 'auto',\n    maxRequestSizeInBytes = MIN_MAX_REQUEST_SIZE_IN_BYTES,\n    requestAbortTimeout = undefined,\n    logger = undefined,\n  }: S3Config) {\n    this._validateConstructorParams(accessKeyId, secretAccessKey, endpoint, bucketName);\n    this.accessKeyId = accessKeyId;\n    this.secretAccessKey = secretAccessKey;\n    this.endpoint = endpoint;\n    this.bucketName = bucketName;\n    this.region = region;\n    this.maxRequestSizeInBytes = maxRequestSizeInBytes;\n    this.requestAbortTimeout = requestAbortTimeout;\n    this.logger = logger;\n  }\n\n  private _validateConstructorParams(\n    accessKeyId: string,\n    secretAccessKey: string,\n    endpoint: string,\n    bucketName: string,\n  ): void {\n    if (typeof accessKeyId !== 'string' || accessKeyId.trim().length === 0)\n      throw new TypeError(ERROR_ACCESS_KEY_REQUIRED);\n    if (typeof secretAccessKey !== 'string' || secretAccessKey.trim().length === 0)\n      throw new TypeError(ERROR_SECRET_KEY_REQUIRED);\n    if (typeof endpoint !== 'string' || endpoint.trim().length === 0) throw new TypeError(ERROR_ENDPOINT_REQUIRED);\n    if (typeof bucketName !== 'string' || bucketName.trim().length === 0)\n      throw new TypeError(ERROR_BUCKET_NAME_REQUIRED);\n  }\n\n  private _checkMethodHeadnGet(method: string): void {\n    if (method !== 'GET' && method !== 'HEAD') {\n      this._log('error', `${ERROR_PREFIX}method must be either GET or HEAD`);\n      throw new Error('method must be either GET or HEAD');\n    }\n  }\n\n  private _checkKey(key: string): void {\n    if (typeof key !== 'string' || key.trim().length === 0) {\n      this._log('error', ERROR_KEY_REQUIRED);\n      throw new TypeError(ERROR_KEY_REQUIRED);\n    }\n  }\n\n  private _checkDelimiter(delimiter: string): void {\n    if (typeof delimiter !== 'string' || delimiter.trim().length === 0) {\n      this._log('error', ERROR_DELIMITER_REQUIRED);\n      throw new TypeError(ERROR_DELIMITER_REQUIRED);\n    }\n  }\n\n  private _checkPrefix(prefix: string): void {\n    if (typeof prefix !== 'string') {\n      this._log('error', ERROR_PREFIX_TYPE);\n      throw new TypeError(ERROR_PREFIX_TYPE);\n    }\n  }\n\n  private _checkMaxKeys(maxKeys: number): void {\n    if (typeof maxKeys !== 'number' || maxKeys <= 0) {\n      this._log('error', ERROR_MAX_KEYS_TYPE);\n      throw new TypeError(ERROR_MAX_KEYS_TYPE);\n    }\n  }\n\n  private _checkOpts(opts: Record<string, any>): void {\n    if (typeof opts !== 'object') {\n      this._log('error', `${ERROR_PREFIX}opts must be an object`);\n      throw new TypeError(`${ERROR_PREFIX}opts must be an object`);\n    }\n  }\n\n  /**\n   * Internal method to log messages with sanitized sensitive information.\n   * @param {string} level - The log level (e.g., 'info', 'warn', 'error').\n   * @param {string} message - The message to log.\n   * @param {Object} [additionalData={}] - Additional data to include in the log.\n   * @private\n   */\n  private _log(\n    level: 'info' | 'warn' | 'error',\n    message: string,\n    additionalData: Record<string, any> | string = {},\n  ): void {\n    if (this.logger && typeof this.logger[level] === 'function') {\n      // Function to recursively sanitize an object\n      const sanitize = (obj: any): any => {\n        if (typeof obj !== 'object' || obj === null) {\n          return obj;\n        }\n        return Object.keys(obj).reduce(\n          (acc: any, key) => {\n            if (SENSITIVE_KEYS_REDACTED.includes(key.toLowerCase())) {\n              acc[key] = '[REDACTED]';\n            } else if (typeof obj[key] === 'object' && obj[key] !== null) {\n              acc[key] = sanitize(obj[key]);\n            } else {\n              acc[key] = obj[key];\n            }\n            return acc;\n          },\n          Array.isArray(obj) ? [] : {},\n        );\n      };\n\n      // Sanitize the additional data\n      const sanitizedData = sanitize(additionalData);\n      // Prepare the log entry\n      const logEntry = {\n        timestamp: new Date().toISOString(),\n        level,\n        message,\n        ...sanitizedData,\n        // Include some general context, but sanitize sensitive parts\n        context: sanitize({\n          bucketName: this.bucketName,\n          region: this.region,\n          endpoint: this.endpoint,\n          // Only include the first few characters of the access key, if it exists\n          accessKeyId: this.accessKeyId ? `${this.accessKeyId.substring(0, 4)}...` : undefined,\n        }),\n      };\n\n      // Log the sanitized entry\n      this.logger[level](logEntry);\n    }\n  }\n\n  getBucketName = () => this.bucketName;\n  setBucketName = (bucketName: string) => {\n    this.bucketName = bucketName;\n  };\n  getRegion = () => this.region;\n  setRegion = (region: string) => {\n    this.region = region;\n  };\n  getEndpoint = () => this.endpoint;\n  setEndpoint = (endpoint: string) => {\n    this.endpoint = endpoint;\n  };\n  getMaxRequestSizeInBytes = () => this.maxRequestSizeInBytes;\n  setMaxRequestSizeInBytes = (maxRequestSizeInBytes: number) => {\n    this.maxRequestSizeInBytes = maxRequestSizeInBytes;\n  };\n\n  getProps = () => ({\n    accessKeyId: this.accessKeyId,\n    secretAccessKey: this.secretAccessKey,\n    region: this.region,\n    bucket: this.bucketName,\n    endpoint: this.endpoint,\n    maxRequestSizeInBytes: this.maxRequestSizeInBytes,\n    requestAbortTimeout: this.requestAbortTimeout,\n    logger: this.logger,\n  });\n  setProps = (props: S3Config) => {\n    this._validateConstructorParams(props.accessKeyId, props.secretAccessKey, props.bucketName, props.endpoint);\n    this.accessKeyId = props.accessKeyId;\n    this.secretAccessKey = props.secretAccessKey;\n    this.region = props.region || 'auto';\n    this.bucketName = props.bucketName;\n    this.endpoint = props.endpoint;\n    this.maxRequestSizeInBytes = props.maxRequestSizeInBytes || MIN_MAX_REQUEST_SIZE_IN_BYTES;\n    this.requestAbortTimeout = props.requestAbortTimeout;\n    this.logger = props.logger;\n  };\n\n  /**\n   * Get the content length of an object.\n   * @param {string} key - The key of the object.\n   * @returns {Promise<number>} The content length of the object in bytes.\n   * @throws {TypeError} If the key is not a non-empty string.\n   */\n  async getContentLength(key: string): Promise<number> {\n    this._checkKey(key);\n    const headers = {\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('HEAD', encodedKey, {}, headers, '');\n    const res = await this._sendRequest(url, 'HEAD', signedHeaders);\n    const contentLength = res.headers.get(HEADER_CONTENT_LENGTH);\n    return contentLength ? parseInt(contentLength, 10) : 0;\n  }\n\n  /**\n   * Check if a bucket exists.\n   * @returns {Promise<boolean>} True if the bucket exists, false otherwise.\n   */\n  async bucketExists(): Promise<boolean> {\n    const headers = {\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n    const { url, headers: signedHeaders } = await this._sign('HEAD', '', {}, headers, '');\n    const res = await this._sendRequest(url, 'HEAD', signedHeaders);\n    if (res.ok && res.status === 200) {\n      return true;\n    }\n    return false;\n  }\n\n  // TBD\n  // async createBucket(bucketName) {\n  //   const xmlBody = `\n  //   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  //     <CreateBucketConfiguration xmlns=\"http://s3.amazonaws.com/doc/2006-03-01/\">\n  //     <LocationConstraint>${this.region}</LocationConstraint>\n  //   </CreateBucketConfiguration>\n  //   `;\n  //   const headers = {\n  //     [HEADER_CONTENT_TYPE]: XML_CONTENT_TYPE,\n  //     [HEADER_CONTENT_LENGTH]: Buffer.byteLength(xmlBody).toString(),\n  //     [HEADER_AMZ_CONTENT_SHA256]: await _hash(xmlBody),\n  //   };\n  //   const encodedKey = encodeURI(bucketName);\n  //   const { url, headers: signedHeaders } = await this._sign('PUT', encodedKey, {}, headers, '');\n  //   const res = await this._sendRequest(url, 'PUT', signedHeaders);\n  //   if (res.ok && res.status === 200) {\n  //     return true;\n  //   }\n  //   return false;\n  // }\n\n  /**\n   * Check if a file exists in the bucket.\n   * @param {string} key - The key of the object.\n   * @returns {Promise<boolean>} True if the file exists, false otherwise.\n   * @throws {TypeError} If the key is not a non-empty string.\n   */\n  async fileExists(key: string): Promise<boolean> {\n    this._checkKey(key);\n    const headers = { [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD };\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('HEAD', encodedKey, {}, headers, '');\n    try {\n      const res = await fetch(url, {\n        method: 'HEAD',\n        headers: signedHeaders,\n      });\n      if (res.ok && res.status === 200) return true;\n      else if (res.status === 404) return false;\n      else this._handleErrorResponse(res);\n      return false;\n    } catch (error: unknown) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this._log('error', `${ERROR_PREFIX}Failed to check if file exists: ${errorMessage}`);\n      throw new Error(`${ERROR_PREFIX}Failed to check if file exists: ${errorMessage}`);\n    }\n  }\n  private async _sign(\n    method: HttpMethod,\n    keyPath: string,\n    query: Object,\n    headers: Record<string, string | number>,\n    body: string | Buffer,\n  ): Promise<{ url: string; headers: Record<string, any> }> {\n    const datetime = new Date().toISOString().replace(/[:-]|\\.\\d{3}/g, '');\n    const url =\n      typeof keyPath === 'string' && keyPath.length > 0 ? new URL(keyPath, this.endpoint) : new URL(this.endpoint);\n    url.pathname = `/${encodeURI(this.bucketName)}${url.pathname}`;\n    headers[HEADER_AMZ_CONTENT_SHA256] = body ? await _hash(body) : UNSIGNED_PAYLOAD;\n    headers[HEADER_AMZ_DATE] = datetime;\n    headers[HEADER_HOST] = url.host;\n    const canonicalHeaders = this._buildCanonicalHeaders(headers);\n    const signedHeaders = Object.keys(headers)\n      .map(key => key.toLowerCase())\n      .sort()\n      .join(';');\n\n    const canonicalRequest = await this._buildCanonicalRequest(\n      method,\n      url,\n      query,\n      canonicalHeaders,\n      signedHeaders,\n      body,\n    );\n    const stringToSign = await this._buildStringToSign(datetime, canonicalRequest);\n    const signature = await this._calculateSignature(datetime, stringToSign);\n    const authorizationHeader = this._buildAuthorizationHeader(datetime, signedHeaders, signature);\n    headers[HEADER_AUTHORIZATION] = authorizationHeader;\n    return { url: url.toString(), headers };\n  }\n\n  private _buildCanonicalHeaders(headers: Record<string, string | number>): string {\n    return Object.entries(headers)\n      .map(([key, value]) => `${key.toLowerCase()}:${String(value).trim()}`)\n      .sort()\n      .join('\\n');\n  }\n\n  async _buildCanonicalRequest(\n    method: HttpMethod,\n    url: URL,\n    query: Object,\n    canonicalHeaders: string,\n    signedHeaders: string,\n    body: string | Buffer,\n  ): Promise<string> {\n    return [\n      method,\n      url.pathname,\n      this._buildCanonicalQueryString(query),\n      `${canonicalHeaders}\\n`,\n      signedHeaders,\n      body ? await _hash(body) : UNSIGNED_PAYLOAD,\n    ].join('\\n');\n  }\n\n  async _buildStringToSign(datetime: string, canonicalRequest: string): Promise<string> {\n    const credentialScope = [datetime.slice(0, 8), this.region, S3_SERVICE, AWS_REQUEST_TYPE].join('/');\n    return [AWS_ALGORITHM, datetime, credentialScope, await _hash(canonicalRequest)].join('\\n');\n  }\n\n  async _calculateSignature(datetime: string, stringToSign: string): Promise<string> {\n    const signingKey = await this._getSignatureKey(datetime.slice(0, 8));\n    return _hmac(signingKey, stringToSign, 'hex');\n  }\n\n  private _buildAuthorizationHeader(datetime: string, signedHeaders: string, signature: string): string {\n    const credentialScope = [datetime.slice(0, 8), this.region, S3_SERVICE, AWS_REQUEST_TYPE].join('/');\n    return [\n      `${AWS_ALGORITHM} Credential=${this.accessKeyId}/${credentialScope}`,\n      `SignedHeaders=${signedHeaders}`,\n      `Signature=${signature}`,\n    ].join(', ');\n  }\n\n  private _filterIfHeaders(opts: Record<string, any>): {\n    filteredOpts: Record<string, any>;\n    conditionalHeaders: Record<string, string>;\n  } {\n    const filteredOpts: Record<string, any> = {};\n    const conditionalHeaders: Record<string, string> = {};\n    const ifHeaders = ['if-match', 'if-none-match', 'if-modified-since', 'if-unmodified-since'];\n\n    for (const [key, value] of Object.entries(opts)) {\n      if (ifHeaders.includes(key)) {\n        conditionalHeaders[key] = value;\n      } else {\n        filteredOpts[key] = value;\n      }\n    }\n\n    return { filteredOpts, conditionalHeaders };\n  }\n  /**\n   * List objects in the bucket.\n   * @param {string} [delimiter='/'] - The delimiter to use for grouping objects in specific path.\n   * @param {string} [prefix=''] - The prefix to filter objects in specific path.\n   * @param {number} [maxKeys=1000] - The maximum number of keys to return.\n   * @param {string} [method='GET'] - The HTTP method to use (GET or HEAD).\n   * @param {Object} [opts={}] - Additional options for the list operation.\n   * @returns {Promise<Object|Array>} The list of objects or object metadata.\n   * @throws {TypeError} If any of the parameters are of incorrect type.\n   */\n  async list(\n    delimiter: string = '/',\n    prefix: string = '',\n    maxKeys: number = 1000,\n    method: HttpMethod = 'GET',\n    opts: Object = {},\n  ): Promise<Object | Array<Object>> {\n    this._checkDelimiter(delimiter);\n    this._checkPrefix(prefix);\n    this._checkMaxKeys(maxKeys);\n    this._checkMethodHeadnGet(method);\n    this._checkOpts(opts);\n    this._log('info', `Listing objects in ${prefix}`);\n\n    const query = {\n      'list-type': LIST_TYPE,\n      'max-keys': String(maxKeys),\n      ...opts,\n    } as { [key: string]: any };\n    if (prefix.length > 0) {\n      query['prefix'] = prefix;\n    }\n    const headers = {\n      [HEADER_CONTENT_TYPE]: JSON_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n    const encodedKey = delimiter === '/' ? delimiter : uriEscape(delimiter);\n    const { url, headers: signedHeaders } = await this._sign('GET', encodedKey, query, headers, '');\n    const urlWithQuery = `${url}?${new URLSearchParams(query)}`;\n    const res = await this._sendRequest(urlWithQuery, 'GET', signedHeaders);\n    const responseBody = await res.text();\n\n    if (method === 'HEAD') {\n      const contentLength = res.headers.get(HEADER_CONTENT_LENGTH);\n      const lastModified = res.headers.get(HEADER_LAST_MODIFIED);\n      const etag = res.headers.get(HEADER_ETAG);\n\n      return {\n        size: contentLength ? +contentLength : undefined,\n        mtime: lastModified ? new Date(lastModified) : undefined,\n        ETag: etag || undefined,\n      };\n    }\n\n    const data = _parseXml(responseBody);\n    const output = data.listBucketResult || data.error || data;\n    return output.contents || output;\n  }\n\n  /**\n   * List multipart uploads in the bucket.\n   * @param {string} [delimiter='/'] - The delimiter to use for grouping objects in specific path.\n   * @param {string} [prefix=''] - The prefix to filter objects in specific path.\n   * @param {string} [method='GET'] - The HTTP method to use (GET or HEAD).\n   * @param {Object} [opts={}] - Additional options for the list operation.\n   * @returns {Promise<Object|Array>} The list of objects or object metadata.\n   * @throws {TypeError} If any of the parameters are of incorrect type.\n   */\n  async listMultiPartUploads(\n    delimiter: string = '/',\n    prefix: string = '',\n    method: HttpMethod = 'GET',\n    opts: Object = {},\n  ): Promise<any> {\n    this._checkDelimiter(delimiter);\n    this._checkPrefix(prefix);\n    this._checkMethodHeadnGet(method);\n    this._checkOpts(opts);\n    this._log('info', `Listing multipart uploads in ${prefix}`);\n\n    const query = {\n      uploads: '',\n      ...opts,\n    } as Record<string, any>;\n    const headers = {\n      [HEADER_CONTENT_TYPE]: JSON_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n    const encodedKey = delimiter === '/' ? delimiter : uriEscape(delimiter);\n    const { url, headers: signedHeaders } = await this._sign('GET', encodedKey, query, headers, '');\n    const urlWithQuery = `${url}?${new URLSearchParams(query)}`;\n    const res = await this._sendRequest(urlWithQuery, 'GET', signedHeaders);\n    const responseBody = await res.text();\n\n    if (method === 'HEAD') {\n      return {\n        size: +(res.headers.get(HEADER_CONTENT_LENGTH) ?? '0'),\n        mtime: new Date(res.headers.get(HEADER_LAST_MODIFIED) ?? ''),\n        ETag: res.headers.get(HEADER_ETAG) ?? '',\n      };\n    }\n\n    const data = _parseXml(responseBody);\n    const output = data.listMultipartUploadsResult || data.error || data;\n    return output.uploads || output;\n  }\n\n  /**\n   * Get an object from the bucket.\n   * @param {string} key - The key of the object to get.\n   * @param {Object} [opts={}] - Additional options for the get operation.\n   * @returns {Promise<string>} The content of the object.\n   */\n  async get(key: string, opts: Record<string, any> = {}): Promise<string> {\n    this._checkKey(key);\n    this._log('info', `Getting object ${key}`);\n    const { filteredOpts, conditionalHeaders } = this._filterIfHeaders(opts);\n    const headers = {\n      [HEADER_CONTENT_TYPE]: JSON_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n      ...conditionalHeaders,\n    };\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('GET', encodedKey, filteredOpts, headers, '');\n    const res = await this._sendRequest(url, 'GET', signedHeaders);\n    return res.text();\n  }\n\n  /**\n   *\n   * @param {string} key - The key of the object to get.\n   * @param {Object} [opts={}] - Additional options for the get operation.\n   * @returns {Promise<{ etag: string; data: string }>} The content of the object.\n   */\n  async getObjectWithETag(key: string, opts: Record<string, any> = {}): Promise<{ etag: string; data: string }> {\n    this._checkKey(key);\n    this._log('info', `Getting object ${key}`);\n    const { filteredOpts, conditionalHeaders } = this._filterIfHeaders(opts);\n    const headers = {\n      [HEADER_CONTENT_TYPE]: JSON_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n      ...conditionalHeaders,\n    };\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('GET', encodedKey, filteredOpts, headers, '');\n    try {\n      const res = await this._sendRequest(url, 'GET', signedHeaders);\n      if (!res.ok) {\n        throw new Error(`Failed to get object. Status: ${res.status}`);\n      }\n\n      const etag = res.headers.get('etag');\n      if (!etag) {\n        throw new Error('ETag not found in response headers');\n      }\n      const data = await res.text();\n      return { etag, data };\n    } catch (error) {\n      this._log('error', `Error getting object ${key} with ETag: ${error}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Get the ETag of an object.\n   * @param {string} key - The key of the object to get.\n   * @param {Object} [opts={}] - Additional options for the get operation.\n   * @returns {Promise<string|null>} The ETag of the object or null if the object etag does not match.\n   */\n  async getEtag(key: string, opts: Record<string, any> = {}): Promise<string | null> {\n    this._checkKey(key);\n    this._log('info', `Getting etag object ${key}`);\n    const { filteredOpts, conditionalHeaders } = this._filterIfHeaders(opts);\n    const headers = {\n      [HEADER_CONTENT_TYPE]: JSON_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n      ...conditionalHeaders,\n    };\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('HEAD', encodedKey, filteredOpts, headers, '');\n\n    const res = await this._sendRequest(url, 'HEAD', signedHeaders);\n    this._log('info', `Response status: ${(res.status, res.statusText)}`);\n    if (!res.ok && res.status === 412) {\n      // etag does not match\n      return null;\n    }\n\n    const etag = res.headers.get('etag');\n    if (!etag) {\n      throw new Error('ETag not found in response headers');\n    }\n    return etag;\n  }\n\n  /**\n   * Get a response of an object from the bucket.\n   * @param {string} key - The key of the object to get.\n   * @param {boolean} [wholeFile=true] - Whether to get the whole file or a part.\n   * @param {number} [rangeFrom=0] - The range from to get if not getting the whole file.\n   * @param {number} [rangeTo=this.maxRequestSizeInBytes] - The range to to get if not getting the whole file. Note: rangeTo is inclusive.\n   * @param {Object} [opts={}] - Additional options for the get operation.\n   * @returns {Promise<Response>} Response of the object content. Use readableStream() to get the stream from .body.\n   */\n  async getResponse(\n    key: string,\n    wholeFile: boolean = true,\n    rangeFrom: number = 0,\n    rangeTo: number = this.maxRequestSizeInBytes,\n    opts: Record<string, any> = {},\n  ): Promise<Response> {\n    this._checkKey(key);\n    // const query = opts;\n    const { filteredOpts, conditionalHeaders } = this._filterIfHeaders(opts);\n    const headers = {\n      [HEADER_CONTENT_TYPE]: JSON_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n      ...conditionalHeaders,\n    };\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('GET', encodedKey, filteredOpts, headers, '');\n    const urlWithQuery = `${url}?${new URLSearchParams(filteredOpts)}`;\n\n    return this._sendRequest(urlWithQuery, 'GET', signedHeaders);\n  }\n\n  /**\n   * Put an object into the bucket.\n   * @param {string} key - The key of the object to put. To create a folder, include a trailing slash.\n   * @param {Buffer|string} data - The content of the object to put.\n   * @returns {Promise<Object>} The response from the put operation.\n   * @throws {TypeError} If the key is not a non-empty string or data is not a Buffer or string.\n   */\n  async put(key: string, data: string | Buffer): Promise<Object> {\n    this._checkKey(key);\n    if (!(data instanceof Buffer || typeof data === 'string')) {\n      this._log('error', ERROR_DATA_BUFFER_REQUIRED);\n      throw new TypeError(ERROR_DATA_BUFFER_REQUIRED);\n    }\n    // const encodedKey = encodeURIComponent(key);\n    this._log('info', `Uploading object ${key}`);\n    const contentLength = typeof data === 'string' ? Buffer.byteLength(data) : data.length;\n    const headers = {\n      [HEADER_CONTENT_LENGTH]: contentLength,\n    };\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('PUT', encodedKey, {}, headers, data);\n    const res = await this._sendRequest(url, 'PUT', signedHeaders, data);\n    return res;\n  }\n\n  /**\n   * Initiate a multipart upload.\n   * @param {string} key - The key of the object to upload.\n   * @param {string} [fileType='application/octet-stream'] - The MIME type of the file.\n   * @returns {Promise<string>} The upload ID for the multipart upload.\n   * @throws {TypeError} If the key is not a non-empty string or fileType is not a string.\n   * @throws {Error} If the multipart upload initiation fails.\n   */\n  async getMultipartUploadId(key: string, fileType: string = DEFAULT_STREAM_CONTENT_TYPE): Promise<string> {\n    this._checkKey(key);\n    if (typeof fileType !== 'string') {\n      this._log('error', `${ERROR_PREFIX}fileType must be a string`);\n      throw new TypeError(`${ERROR_PREFIX}fileType must be a string`);\n    }\n    this._log('info', `Initiating multipart upload for object ${key}`);\n    const query = { uploads: '' };\n    const headers = {\n      [HEADER_CONTENT_TYPE]: fileType,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('POST', encodedKey, query, headers, '');\n    const urlWithQuery = `${url}?${new URLSearchParams(query)}`;\n\n    const res = await this._sendRequest(urlWithQuery, 'POST', signedHeaders);\n    const responseBody = await res.text();\n    const parsedResponse = _parseXml(responseBody);\n\n    if (\n      typeof parsedResponse === 'object' &&\n      parsedResponse !== null &&\n      'error' in parsedResponse &&\n      typeof parsedResponse.error === 'object' &&\n      parsedResponse.error !== null &&\n      'message' in parsedResponse.error\n    ) {\n      const errorMessage = String(parsedResponse.error.message);\n      this._log('error', `${ERROR_PREFIX}Failed to abort multipart upload: ${errorMessage}`);\n      throw new Error(`${ERROR_PREFIX}Failed to abort multipart upload: ${errorMessage}`);\n    }\n\n    if (typeof parsedResponse === 'object' && parsedResponse !== null) {\n      if (!parsedResponse.initiateMultipartUploadResult || !parsedResponse.initiateMultipartUploadResult.uploadId) {\n        this._log('error', `${ERROR_PREFIX}Failed to create multipart upload: no uploadId in response`);\n        throw new Error(`${ERROR_PREFIX}Failed to create multipart upload: Missing upload ID in response`);\n      }\n\n      return parsedResponse.initiateMultipartUploadResult.uploadId;\n    } else {\n      this._log('error', `${ERROR_PREFIX}Failed to create multipart upload: unexpected response format`);\n      throw new Error(`${ERROR_PREFIX}Failed to create multipart upload: Unexpected response format`);\n    }\n  }\n\n  /**\n   * Upload a part in a multipart upload.\n   * @param {string} key - The key of the object being uploaded.\n   * @param {Buffer|string} data - The content of the part.\n   * @param {string} uploadId - The upload ID of the multipart upload.\n   * @param {number} partNumber - The part number.\n   * @param {Object} [opts={}] - Additional options for the upload.\n   * @returns {Promise<Object>} The ETag and part number of the uploaded part.\n   * @throws {TypeError} If any of the parameters are of incorrect type.\n   */\n  async uploadPart(\n    key: string,\n    data: Buffer | string,\n    uploadId: string,\n    partNumber: number,\n    opts: Object = {},\n  ): Promise<UploadPart> {\n    this._validateUploadPartParams(key, data, uploadId, partNumber, opts);\n    const query = { uploadId, partNumber, ...opts } as { [key: string]: any };\n    const headers = {\n      [HEADER_CONTENT_LENGTH]: data.length,\n    } as { [key: string]: any };\n\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('PUT', encodedKey, query, headers, data);\n    const urlWithQuery = `${url}?${new URLSearchParams(query)}`;\n\n    const res = await this._sendRequest(urlWithQuery, 'PUT', signedHeaders, data);\n    const ETag = res.headers.get('etag') || '';\n    return { partNumber, ETag };\n  }\n\n  private _validateUploadPartParams(\n    key: string,\n    data: Buffer | string,\n    uploadId: string,\n    partNumber: number,\n    opts: Object,\n  ) {\n    this._checkKey(key);\n    if (!(data instanceof Buffer || typeof data === 'string')) {\n      this._log('error', ERROR_DATA_BUFFER_REQUIRED);\n      throw new TypeError(ERROR_DATA_BUFFER_REQUIRED);\n    }\n    if (typeof uploadId !== 'string' || uploadId.trim().length === 0) {\n      this._log('error', ERROR_UPLOAD_ID_REQUIRED);\n      throw new TypeError(ERROR_UPLOAD_ID_REQUIRED);\n    }\n    if (!Number.isInteger(partNumber) || partNumber <= 0) {\n      this._log('error', `${ERROR_PREFIX}partNumber must be a positive integer`);\n      throw new TypeError(`${ERROR_PREFIX}partNumber must be a positive integer`);\n    }\n    this._checkOpts(opts);\n  }\n\n  /**\n   * Complete a multipart upload.\n   * @param {string} key - The key of the object being uploaded.\n   * @param {string} uploadId - The upload ID of the multipart upload.\n   * @param {Array<Object>} parts - An array of objects containing PartNumber and ETag for each part.\n   * @returns {Promise<Object>} The result of the complete multipart upload operation.\n   * @throws {TypeError} If any of the parameters are of incorrect type.\n   * @throws {Error} If the complete multipart upload operation fails.\n   */\n  async completeMultipartUpload(\n    key: string,\n    uploadId: string,\n    parts: Array<UploadPart>,\n  ): Promise<CompleteMultipartUploadResult> {\n    this._checkKey(key);\n    if (typeof uploadId !== 'string' || uploadId.trim().length === 0) {\n      this._log('error', ERROR_UPLOAD_ID_REQUIRED);\n      throw new TypeError(ERROR_UPLOAD_ID_REQUIRED);\n    }\n    if (!Array.isArray(parts) || parts.length === 0) {\n      this._log('error', ERROR_PARTS_REQUIRED);\n      throw new TypeError(ERROR_PARTS_REQUIRED);\n    }\n    if (!parts.every(part => typeof part.partNumber === 'number' && typeof part.ETag === 'string')) {\n      this._log('error', ERROR_INVALID_PART);\n      throw new TypeError(ERROR_INVALID_PART);\n    }\n    this._log('info', `Complete multipart upload ${uploadId} for object ${key}`);\n    const query = { uploadId };\n    const xmlBody = this._buildCompleteMultipartUploadXml(parts);\n    const headers = {\n      [HEADER_CONTENT_TYPE]: XML_CONTENT_TYPE,\n      [HEADER_CONTENT_LENGTH]: Buffer.byteLength(xmlBody).toString(),\n      [HEADER_AMZ_CONTENT_SHA256]: await _hash(xmlBody),\n    };\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('POST', encodedKey, query, headers, xmlBody);\n    const urlWithQuery = `${url}?${new URLSearchParams(query)}`;\n\n    const res = await this._sendRequest(urlWithQuery, 'POST', signedHeaders, xmlBody);\n    const responseBody = await res.text();\n    const parsedResponse = _parseXml(responseBody);\n\n    if (\n      typeof parsedResponse === 'object' &&\n      parsedResponse !== null &&\n      'error' in parsedResponse &&\n      typeof parsedResponse.error === 'object' &&\n      parsedResponse.error !== null &&\n      'message' in parsedResponse.error\n    ) {\n      const errorMessage = String(parsedResponse.error.message);\n      this._log('error', `${ERROR_PREFIX}Failed to abort multipart upload: ${errorMessage}`);\n      throw new Error(`${ERROR_PREFIX}Failed to abort multipart upload: ${errorMessage}`);\n    }\n\n    return parsedResponse.completeMultipartUploadResult;\n  }\n\n  /**\n   * Aborts a multipart upload.\n   * @param {string} key - The key of the object being uploaded.\n   * @param {string} uploadId - The ID of the multipart upload to abort.\n   * @returns {Promise<Object>} - A promise that resolves to the abort response.\n   * @throws {Error} If the abort operation fails.\n   */\n  async abortMultipartUpload(key: string, uploadId: string): Promise<object> {\n    // Input validation\n    this._checkKey(key);\n    if (typeof uploadId !== 'string' || uploadId.trim().length === 0) {\n      this._log('error', ERROR_UPLOAD_ID_REQUIRED);\n      throw new TypeError(ERROR_UPLOAD_ID_REQUIRED);\n    }\n\n    this._log('info', `Aborting multipart upload ${uploadId} for object ${key}`);\n\n    // Prepare the request\n    const query = { uploadId };\n    const headers = {\n      [HEADER_CONTENT_TYPE]: XML_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n\n    try {\n      // Sign and send the request\n      const encodedKey = uriResourceEscape(key);\n      const { url, headers: signedHeaders } = await this._sign('DELETE', encodedKey, query, headers, '');\n      const urlWithQuery = `${url}?${new URLSearchParams(query)}`;\n\n      const res = await this._sendRequest(urlWithQuery, 'DELETE', signedHeaders);\n\n      // Check for successful response\n      if (res.ok) {\n        const responseBody = await res.text();\n        const parsedResponse = _parseXml(responseBody);\n\n        if (\n          typeof parsedResponse === 'object' &&\n          parsedResponse !== null &&\n          'error' in parsedResponse &&\n          typeof parsedResponse.error === 'object' &&\n          parsedResponse.error !== null &&\n          'message' in parsedResponse.error\n        ) {\n          const errorMessage = String(parsedResponse.error.message);\n          this._log('error', `${ERROR_PREFIX}Failed to abort multipart upload: ${errorMessage}`);\n          throw new Error(`${ERROR_PREFIX}Failed to abort multipart upload: ${errorMessage}`);\n        }\n\n        return {\n          status: 'Aborted',\n          key,\n          uploadId,\n          response: parsedResponse,\n        };\n      } else {\n        this._log('error', `${ERROR_PREFIX}Abort request failed with status ${res.status}`);\n        throw new Error(`${ERROR_PREFIX}Abort request failed with status ${res.status}`);\n      }\n    } catch (error: unknown) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this._log('error', `${ERROR_PREFIX}Failed to abort multipart upload for key ${key}: ${errorMessage}`);\n      throw new Error(`${ERROR_PREFIX}Failed to abort multipart upload for key ${key}: ${errorMessage}`);\n    }\n  }\n\n  private _buildCompleteMultipartUploadXml(parts: Array<UploadPart>): string {\n    return `\n      <CompleteMultipartUpload>\n        ${parts\n          .map(\n            part => `\n          <Part>\n            <PartNumber>${part.partNumber}</PartNumber>\n            <ETag>${part.ETag}</ETag>\n          </Part>\n        `,\n          )\n          .join('')}\n      </CompleteMultipartUpload>\n    `;\n  }\n\n  /**\n   * Delete an object from the bucket.\n   * @param {string} key - The key of the object to delete.\n   * @returns {Promise<boolean>} The response from the delete operation. True if the delete operation was successful, false otherwise. Note: The delete operation may return a 204 status code even if the object was not found.\n   */\n  async delete(key: string): Promise<boolean> {\n    this._checkKey(key);\n    this._log('info', `Deleting object ${key}`);\n    const headers = {\n      [HEADER_CONTENT_TYPE]: JSON_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('DELETE', encodedKey, {}, headers, '');\n    const res = await this._sendRequest(url, 'DELETE', signedHeaders);\n    if (res.status === 204 || res.status === 200) {\n      return true;\n    }\n    return false;\n  }\n\n  async _sendRequest(\n    url: string,\n    method: HttpMethod,\n    headers: Record<string, string | any>,\n    body?: string | Buffer,\n  ): Promise<Response> {\n    this._log('info', `Sending ${method} request to ${url}, headers: ${JSON.stringify(headers)}`);\n    const res = await fetch(url, {\n      method,\n      headers,\n      body,\n      signal: this.requestAbortTimeout !== undefined ? AbortSignal.timeout(this.requestAbortTimeout) : undefined,\n    });\n\n    if (!res.ok) {\n      await this._handleErrorResponse(res);\n    }\n\n    return res;\n  }\n\n  async _handleErrorResponse(res: Response) {\n    const errorBody = await res.text();\n    const errorCode = res.headers.get('x-amz-error-code') || 'Unknown';\n    const errorMessage = res.headers.get('x-amz-error-message') || res.statusText;\n    this._log(\n      'error',\n      `${ERROR_PREFIX}Request failed with status ${res.status}: ${errorCode} - ${errorMessage},err body: ${errorBody}`,\n    );\n    throw new Error(\n      `${ERROR_PREFIX}Request failed with status ${res.status}: ${errorCode} - ${errorMessage}, err body: ${errorBody}`,\n    );\n  }\n\n  _buildCanonicalQueryString(queryParams: Object): string {\n    if (Object.keys(queryParams).length < 1) {\n      return '';\n    }\n\n    return Object.keys(queryParams)\n      .sort()\n      .map(key => `${encodeURIComponent(key)}=${encodeURIComponent((queryParams as Record<string, any>)[key])}`)\n      .join('&');\n  }\n  async _getSignatureKey(dateStamp: string): Promise<string> {\n    const kDate = await _hmac(`AWS4${this.secretAccessKey}`, dateStamp);\n    const kRegion = await _hmac(kDate, this.region);\n    const kService = await _hmac(kRegion, S3_SERVICE);\n    return _hmac(kService, AWS_REQUEST_TYPE);\n  }\n}\n\nconst _hash = async (content: string | Buffer): Promise<string> => {\n  const hashSum = _createHash('sha256');\n  hashSum.update(content);\n  return hashSum.digest('hex');\n};\n\nconst _hmac = async (key: string | Buffer, content: string, encoding?: 'hex'): Promise<string> => {\n  const hmacSum = _createHmac('sha256', key);\n  hmacSum.update(content);\n  return hmacSum.digest(encoding);\n};\n\nconst _parseXml = (str: string): string | object | any => {\n  const unescapeXml = (value: string): string => {\n    return value\n      .replace(/&quot;/g, '\"')\n      .replace(/&apos;/g, \"'\")\n      .replace(/&lt;/g, '<')\n      .replace(/&gt;/g, '>')\n      .replace(/&amp;/g, '&');\n  };\n\n  const json = {};\n  const re = /<(\\w)([-\\w]+)(?:\\/|[^>]*>((?:(?!<\\1)[\\s\\S])*)<\\/\\1\\2)>/gm;\n  let match;\n\n  while ((match = re.exec(str))) {\n    const [, prefix, key, value] = match;\n    const fullKey = prefix.toLowerCase() + key;\n    const parsedValue = value != null ? _parseXml(value) : true;\n\n    if (typeof parsedValue === 'string') {\n      (json as { [key: string]: any })[fullKey] = unescapeXml(parsedValue);\n    } else if (Array.isArray((json as { [key: string]: any })[fullKey])) {\n      (json as { [key: string]: any })[fullKey].push(parsedValue);\n    } else {\n      (json as { [key: string]: any })[fullKey] =\n        (json as { [key: string]: any })[fullKey] != null\n          ? [(json as { [key: string]: any })[fullKey], parsedValue]\n          : expectArray[fullKey]\n            ? [parsedValue]\n            : parsedValue;\n    }\n  }\n\n  return Object.keys(json).length ? json : unescapeXml(str);\n};\n\nexport { S3 };\nexport default S3;\n"],
  "mappings": "AAGA,IAAMA,EAAgB,mBAChBC,EAAmB,eACnBC,EAAa,KACbC,EAAY,IACZC,EAAmB,mBACnBC,EAA8B,2BAC9BC,EAAmB,kBACnBC,EAAoB,mBAEpBC,EAA0B,CAAC,cAAe,kBAAmB,eAAgB,UAAU,EAI7F,IAAMC,EAA4B,uBAC5BC,EAAkB,aAClBC,EAAc,OACdC,EAAuB,gBACvBC,EAAsB,eACtBC,EAAwB,iBACxBC,EAAc,OACdC,EAAuB,gBAGvBC,EAAe,yBACfC,EAA4B,GAAGD,CAAY,yCAC3CE,GAA4B,GAAGF,CAAY,6CAC3CG,GAA0B,GAAGH,CAAY,sCACzCI,GAA6B,GAAGJ,CAAY,wCAC5CK,EAAqB,GAAGL,CAAY,iCACpCM,EAA2B,GAAGN,CAAY,sCAC1CO,EAAuB,GAAGP,CAAY,kCACtCQ,EAAqB,GAAGR,CAAY,8DACpCS,EAA6B,GAAGT,CAAY,kCAE5CU,EAAoB,GAAGV,CAAY,0BACnCW,EAAsB,GAAGX,CAAY,qCACrCY,EAA2B,GAAGZ,CAAY,6BAmEhD,IAAIa,EAAc,OAAO,aAAe,KAAM,QAAO,aAAa,GAAG,WACjEC,EAAc,OAAO,aAAe,KAAM,QAAO,aAAa,GAAG,WAEjE,OAAOD,EAAgB,KAAe,OAAOC,EAAgB,KAC/D,QAAQ,MACN,iKAAiK,EAIrK,IAAMC,GAA0C,CAC9C,SAAU,IAGNC,GAAeC,GAAsB,IAAIA,EAAE,WAAW,CAAC,EAAE,SAAS,EAAE,EAAE,YAAW,CAAE,GAEnFC,EAAaC,GACV,mBAAmBA,CAAM,EAAE,QAAQ,WAAYH,EAAW,EAG7DI,EAAqBC,GAClBH,EAAUG,CAAM,EAAE,QAAQ,OAAQ,GAAG,EA2BxCC,EAAN,KAAQ,CAyBN,YAAY,CACV,YAAAC,EACA,gBAAAC,EACA,SAAAC,EACA,WAAAC,EACA,OAAAC,EAAS,OACT,sBAAAC,EAAwB,QACxB,oBAAAC,EAAsB,OACtB,OAAAC,EAAS,MAAS,EACT,CA6HX,KAAA,cAAgB,IAAM,KAAK,WAC3B,KAAA,cAAiBJ,GAAsB,CACrC,KAAK,WAAaA,CACpB,EACA,KAAA,UAAY,IAAM,KAAK,OACvB,KAAA,UAAaC,GAAkB,CAC7B,KAAK,OAASA,CAChB,EACA,KAAA,YAAc,IAAM,KAAK,SACzB,KAAA,YAAeF,GAAoB,CACjC,KAAK,SAAWA,CAClB,EACA,KAAA,yBAA2B,IAAM,KAAK,sBACtC,KAAA,yBAA4BG,GAAiC,CAC3D,KAAK,sBAAwBA,CAC/B,EAEA,KAAA,SAAW,KAAO,CAChB,YAAa,KAAK,YAClB,gBAAiB,KAAK,gBACtB,OAAQ,KAAK,OACb,OAAQ,KAAK,WACb,SAAU,KAAK,SACf,sBAAuB,KAAK,sBAC5B,oBAAqB,KAAK,oBAC1B,OAAQ,KAAK,SAEf,KAAA,SAAYG,GAAmB,CAC7B,KAAK,2BAA2BA,EAAM,YAAaA,EAAM,gBAAiBA,EAAM,WAAYA,EAAM,QAAQ,EAC1G,KAAK,YAAcA,EAAM,YACzB,KAAK,gBAAkBA,EAAM,gBAC7B,KAAK,OAASA,EAAM,QAAU,OAC9B,KAAK,WAAaA,EAAM,WACxB,KAAK,SAAWA,EAAM,SACtB,KAAK,sBAAwBA,EAAM,uBAAyB,QAC5D,KAAK,oBAAsBA,EAAM,oBACjC,KAAK,OAASA,EAAM,MACtB,EAjKE,KAAK,2BAA2BR,EAAaC,EAAiBC,EAAUC,CAAU,EAClF,KAAK,YAAcH,EACnB,KAAK,gBAAkBC,EACvB,KAAK,SAAWC,EAChB,KAAK,WAAaC,EAClB,KAAK,OAASC,EACd,KAAK,sBAAwBC,EAC7B,KAAK,oBAAsBC,EAC3B,KAAK,OAASC,CAChB,CAEQ,2BACNP,EACAC,EACAC,EACAC,EAAkB,CAElB,GAAI,OAAOH,GAAgB,UAAYA,EAAY,KAAI,EAAG,SAAW,EACnE,MAAM,IAAI,UAAUS,CAAyB,EAC/C,GAAI,OAAOR,GAAoB,UAAYA,EAAgB,KAAI,EAAG,SAAW,EAC3E,MAAM,IAAI,UAAUS,EAAyB,EAC/C,GAAI,OAAOR,GAAa,UAAYA,EAAS,KAAI,EAAG,SAAW,EAAG,MAAM,IAAI,UAAUS,EAAuB,EAC7G,GAAI,OAAOR,GAAe,UAAYA,EAAW,KAAI,EAAG,SAAW,EACjE,MAAM,IAAI,UAAUS,EAA0B,CAClD,CAEQ,qBAAqBC,EAAc,CACzC,GAAIA,IAAW,OAASA,IAAW,OACjC,WAAK,KAAK,QAAS,GAAGC,CAAY,mCAAmC,EAC/D,IAAI,MAAM,mCAAmC,CAEvD,CAEQ,UAAUC,EAAW,CAC3B,GAAI,OAAOA,GAAQ,UAAYA,EAAI,KAAI,EAAG,SAAW,EACnD,WAAK,KAAK,QAASC,CAAkB,EAC/B,IAAI,UAAUA,CAAkB,CAE1C,CAEQ,gBAAgBC,EAAiB,CACvC,GAAI,OAAOA,GAAc,UAAYA,EAAU,KAAI,EAAG,SAAW,EAC/D,WAAK,KAAK,QAASC,CAAwB,EACrC,IAAI,UAAUA,CAAwB,CAEhD,CAEQ,aAAaC,EAAc,CACjC,GAAI,OAAOA,GAAW,SACpB,WAAK,KAAK,QAASC,CAAiB,EAC9B,IAAI,UAAUA,CAAiB,CAEzC,CAEQ,cAAcC,EAAe,CACnC,GAAI,OAAOA,GAAY,UAAYA,GAAW,EAC5C,WAAK,KAAK,QAASC,CAAmB,EAChC,IAAI,UAAUA,CAAmB,CAE3C,CAEQ,WAAWC,EAAyB,CAC1C,GAAI,OAAOA,GAAS,SAClB,WAAK,KAAK,QAAS,GAAGT,CAAY,wBAAwB,EACpD,IAAI,UAAU,GAAGA,CAAY,wBAAwB,CAE/D,CASQ,KACNU,EACAC,EACAC,EAA+C,CAAA,EAAE,CAEjD,GAAI,KAAK,QAAU,OAAO,KAAK,OAAOF,CAAK,GAAM,WAAY,CAE3D,IAAMG,EAAYC,GACZ,OAAOA,GAAQ,UAAYA,IAAQ,KAC9BA,EAEF,OAAO,KAAKA,CAAG,EAAE,OACtB,CAACC,EAAUd,KACLe,EAAwB,SAASf,EAAI,YAAW,CAAE,EACpDc,EAAId,CAAG,EAAI,aACF,OAAOa,EAAIb,CAAG,GAAM,UAAYa,EAAIb,CAAG,IAAM,KACtDc,EAAId,CAAG,EAAIY,EAASC,EAAIb,CAAG,CAAC,EAE5Bc,EAAId,CAAG,EAAIa,EAAIb,CAAG,EAEbc,GAET,MAAM,QAAQD,CAAG,EAAI,CAAA,EAAK,CAAA,CAAE,EAK1BG,EAAgBJ,EAASD,CAAc,EAEvCM,EAAW,CACf,UAAW,IAAI,KAAI,EAAG,YAAW,EACjC,MAAAR,EACA,QAAAC,EACA,GAAGM,EAEH,QAASJ,EAAS,CAChB,WAAY,KAAK,WACjB,OAAQ,KAAK,OACb,SAAU,KAAK,SAEf,YAAa,KAAK,YAAc,GAAG,KAAK,YAAY,UAAU,EAAG,CAAC,CAAC,MAAQ,OAC5E,GAIH,KAAK,OAAOH,CAAK,EAAEQ,CAAQ,CAC7B,CACF,CA+CA,MAAM,iBAAiBjB,EAAW,CAChC,KAAK,UAAUA,CAAG,EAClB,IAAMkB,EAAU,CACd,CAACC,CAAyB,EAAGC,GAEzBC,EAAavC,EAAkBkB,CAAG,EAClC,CAAE,IAAAsB,EAAK,QAASC,CAAa,EAAK,MAAM,KAAK,MAAM,OAAQF,EAAY,CAAA,EAAIH,EAAS,EAAE,EAEtFM,GADM,MAAM,KAAK,aAAaF,EAAK,OAAQC,CAAa,GACpC,QAAQ,IAAIE,CAAqB,EAC3D,OAAOD,EAAgB,SAASA,EAAe,EAAE,EAAI,CACvD,CAMA,MAAM,cAAY,CAChB,IAAMN,EAAU,CACd,CAACC,CAAyB,EAAGC,GAEzB,CAAE,IAAAE,EAAK,QAASC,CAAa,EAAK,MAAM,KAAK,MAAM,OAAQ,GAAI,CAAA,EAAIL,EAAS,EAAE,EAC9EQ,EAAM,MAAM,KAAK,aAAaJ,EAAK,OAAQC,CAAa,EAC9D,MAAI,GAAAG,EAAI,IAAMA,EAAI,SAAW,IAI/B,CA8BA,MAAM,WAAW1B,EAAW,CAC1B,KAAK,UAAUA,CAAG,EAClB,IAAMkB,EAAU,CAAE,CAACC,CAAyB,EAAGC,CAAgB,EACzDC,EAAavC,EAAkBkB,CAAG,EAClC,CAAE,IAAAsB,EAAK,QAASC,CAAa,EAAK,MAAM,KAAK,MAAM,OAAQF,EAAY,CAAA,EAAIH,EAAS,EAAE,EAC5F,GAAI,CACF,IAAMQ,EAAM,MAAM,MAAMJ,EAAK,CAC3B,OAAQ,OACR,QAASC,EACV,EACD,OAAIG,EAAI,IAAMA,EAAI,SAAW,IAAY,IAChCA,EAAI,SAAW,KACnB,KAAK,qBAAqBA,CAAG,EAC3B,GACT,OAASC,EAAgB,CACvB,IAAMC,EAAeD,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,EAC1E,WAAK,KAAK,QAAS,GAAG5B,CAAY,mCAAmC6B,CAAY,EAAE,EAC7E,IAAI,MAAM,GAAG7B,CAAY,mCAAmC6B,CAAY,EAAE,CAClF,CACF,CACQ,MAAM,MACZ9B,EACA+B,EACAC,EACAZ,EACAa,EAAqB,CAErB,IAAMC,EAAW,IAAI,KAAI,EAAG,YAAW,EAAG,QAAQ,gBAAiB,EAAE,EAC/DV,EACJ,OAAOO,GAAY,UAAYA,EAAQ,OAAS,EAAI,IAAI,IAAIA,EAAS,KAAK,QAAQ,EAAI,IAAI,IAAI,KAAK,QAAQ,EAC7GP,EAAI,SAAW,IAAI,UAAU,KAAK,UAAU,CAAC,GAAGA,EAAI,QAAQ,GAC5DJ,EAAQC,CAAyB,EAAIY,EAAO,MAAME,EAAMF,CAAI,EAAIX,EAChEF,EAAQgB,CAAe,EAAIF,EAC3Bd,EAAQiB,CAAW,EAAIb,EAAI,KAC3B,IAAMc,EAAmB,KAAK,uBAAuBlB,CAAO,EACtDK,EAAgB,OAAO,KAAKL,CAAO,EACtC,IAAIlB,GAAOA,EAAI,YAAW,CAAE,EAC5B,KAAI,EACJ,KAAK,GAAG,EAELqC,EAAmB,MAAM,KAAK,uBAClCvC,EACAwB,EACAQ,EACAM,EACAb,EACAQ,CAAI,EAEAO,EAAe,MAAM,KAAK,mBAAmBN,EAAUK,CAAgB,EACvEE,EAAY,MAAM,KAAK,oBAAoBP,EAAUM,CAAY,EACjEE,EAAsB,KAAK,0BAA0BR,EAAUT,EAAegB,CAAS,EAC7F,OAAArB,EAAQuB,CAAoB,EAAID,EACzB,CAAE,IAAKlB,EAAI,SAAQ,EAAI,QAAAJ,CAAO,CACvC,CAEQ,uBAAuBA,EAAwC,CACrE,OAAO,OAAO,QAAQA,CAAO,EAC1B,IAAI,CAAC,CAAClB,EAAK0C,CAAK,IAAM,GAAG1C,EAAI,YAAW,CAAE,IAAI,OAAO0C,CAAK,EAAE,KAAI,CAAE,EAAE,EACpE,KAAI,EACJ,KAAK;CAAI,CACd,CAEA,MAAM,uBACJ5C,EACAwB,EACAQ,EACAM,EACAb,EACAQ,EAAqB,CAErB,MAAO,CACLjC,EACAwB,EAAI,SACJ,KAAK,2BAA2BQ,CAAK,EACrC,GAAGM,CAAgB;EACnBb,EACAQ,EAAO,MAAME,EAAMF,CAAI,EAAIX,GAC3B,KAAK;CAAI,CACb,CAEA,MAAM,mBAAmBY,EAAkBK,EAAwB,CACjE,IAAMM,EAAkB,CAACX,EAAS,MAAM,EAAG,CAAC,EAAG,KAAK,OAAQY,EAAYC,CAAgB,EAAE,KAAK,GAAG,EAClG,MAAO,CAACC,EAAed,EAAUW,EAAiB,MAAMV,EAAMI,CAAgB,CAAC,EAAE,KAAK;CAAI,CAC5F,CAEA,MAAM,oBAAoBL,EAAkBM,EAAoB,CAC9D,IAAMS,EAAa,MAAM,KAAK,iBAAiBf,EAAS,MAAM,EAAG,CAAC,CAAC,EACnE,OAAOgB,EAAMD,EAAYT,EAAc,KAAK,CAC9C,CAEQ,0BAA0BN,EAAkBT,EAAuBgB,EAAiB,CAC1F,IAAMI,EAAkB,CAACX,EAAS,MAAM,EAAG,CAAC,EAAG,KAAK,OAAQY,EAAYC,CAAgB,EAAE,KAAK,GAAG,EAClG,MAAO,CACL,GAAGC,CAAa,eAAe,KAAK,WAAW,IAAIH,CAAe,GAClE,iBAAiBpB,CAAa,GAC9B,aAAagB,CAAS,IACtB,KAAK,IAAI,CACb,CAEQ,iBAAiB/B,EAAyB,CAIhD,IAAMyC,EAAoC,CAAA,EACpCC,EAA6C,CAAA,EAC7CC,EAAY,CAAC,WAAY,gBAAiB,oBAAqB,qBAAqB,EAE1F,OAAW,CAACnD,EAAK0C,CAAK,IAAK,OAAO,QAAQlC,CAAI,EACxC2C,EAAU,SAASnD,CAAG,EACxBkD,EAAmBlD,CAAG,EAAI0C,EAE1BO,EAAajD,CAAG,EAAI0C,EAIxB,MAAO,CAAE,aAAAO,EAAc,mBAAAC,CAAkB,CAC3C,CAWA,MAAM,KACJhD,EAAoB,IACpBE,EAAiB,GACjBE,EAAkB,IAClBR,EAAqB,MACrBU,EAAe,CAAA,EAAE,CAEjB,KAAK,gBAAgBN,CAAS,EAC9B,KAAK,aAAaE,CAAM,EACxB,KAAK,cAAcE,CAAO,EAC1B,KAAK,qBAAqBR,CAAM,EAChC,KAAK,WAAWU,CAAI,EACpB,KAAK,KAAK,OAAQ,sBAAsBJ,CAAM,EAAE,EAEhD,IAAM0B,EAAQ,CACZ,YAAasB,EACb,WAAY,OAAO9C,CAAO,EAC1B,GAAGE,GAEDJ,EAAO,OAAS,IAClB0B,EAAM,OAAY1B,GAEpB,IAAMc,EAAU,CACd,CAACmC,CAAmB,EAAGC,EACvB,CAACnC,CAAyB,EAAGC,GAEzBC,EAAanB,IAAc,IAAMA,EAAYtB,EAAUsB,CAAS,EAChE,CAAE,IAAAoB,EAAK,QAASC,CAAa,EAAK,MAAM,KAAK,MAAM,MAAOF,EAAYS,EAAOZ,EAAS,EAAE,EACxFqC,EAAe,GAAGjC,CAAG,IAAI,IAAI,gBAAgBQ,CAAK,CAAC,GACnDJ,EAAM,MAAM,KAAK,aAAa6B,EAAc,MAAOhC,CAAa,EAChEiC,EAAe,MAAM9B,EAAI,KAAI,EAEnC,GAAI5B,IAAW,OAAQ,CACrB,IAAM0B,EAAgBE,EAAI,QAAQ,IAAID,CAAqB,EACrDgC,EAAe/B,EAAI,QAAQ,IAAIgC,CAAoB,EACnDC,EAAOjC,EAAI,QAAQ,IAAIkC,CAAW,EAExC,MAAO,CACL,KAAMpC,EAAgB,CAACA,EAAgB,OACvC,MAAOiC,EAAe,IAAI,KAAKA,CAAY,EAAI,OAC/C,KAAME,GAAQ,OAElB,CAEA,IAAME,EAAOC,EAAUN,CAAY,EAC7BO,EAASF,EAAK,kBAAoBA,EAAK,OAASA,EACtD,OAAOE,EAAO,UAAYA,CAC5B,CAWA,MAAM,qBACJ7D,EAAoB,IACpBE,EAAiB,GACjBN,EAAqB,MACrBU,EAAe,CAAA,EAAE,WAEjB,KAAK,gBAAgBN,CAAS,EAC9B,KAAK,aAAaE,CAAM,EACxB,KAAK,qBAAqBN,CAAM,EAChC,KAAK,WAAWU,CAAI,EACpB,KAAK,KAAK,OAAQ,gCAAgCJ,CAAM,EAAE,EAE1D,IAAM0B,EAAQ,CACZ,QAAS,GACT,GAAGtB,GAECU,EAAU,CACd,CAACmC,CAAmB,EAAGC,EACvB,CAACnC,CAAyB,EAAGC,GAEzBC,EAAanB,IAAc,IAAMA,EAAYtB,EAAUsB,CAAS,EAChE,CAAE,IAAAoB,EAAK,QAASC,CAAa,EAAK,MAAM,KAAK,MAAM,MAAOF,EAAYS,EAAOZ,EAAS,EAAE,EACxFqC,EAAe,GAAGjC,CAAG,IAAI,IAAI,gBAAgBQ,CAAK,CAAC,GACnDJ,EAAM,MAAM,KAAK,aAAa6B,EAAc,MAAOhC,CAAa,EAChEiC,EAAe,MAAM9B,EAAI,KAAI,EAEnC,GAAI5B,IAAW,OACb,MAAO,CACL,KAAM,GAAEkE,EAAAtC,EAAI,QAAQ,IAAID,CAAqB,KAAC,MAAAuC,IAAA,OAAAA,EAAI,KAClD,MAAO,IAAI,MAAKC,EAAAvC,EAAI,QAAQ,IAAIgC,CAAoB,KAAC,MAAAO,IAAA,OAAAA,EAAI,EAAE,EAC3D,MAAMC,EAAAxC,EAAI,QAAQ,IAAIkC,CAAW,KAAC,MAAAM,IAAA,OAAAA,EAAI,IAI1C,IAAML,EAAOC,EAAUN,CAAY,EAC7BO,EAASF,EAAK,4BAA8BA,EAAK,OAASA,EAChE,OAAOE,EAAO,SAAWA,CAC3B,CAQA,MAAM,IAAI/D,EAAaQ,EAA4B,CAAA,EAAE,CACnD,KAAK,UAAUR,CAAG,EAClB,KAAK,KAAK,OAAQ,kBAAkBA,CAAG,EAAE,EACzC,GAAM,CAAE,aAAAiD,EAAc,mBAAAC,CAAkB,EAAK,KAAK,iBAAiB1C,CAAI,EACjEU,EAAU,CACd,CAACmC,CAAmB,EAAGC,EACvB,CAACnC,CAAyB,EAAGC,EAC7B,GAAG8B,GAEC7B,EAAavC,EAAkBkB,CAAG,EAClC,CAAE,IAAAsB,EAAK,QAASC,CAAa,EAAK,MAAM,KAAK,MAAM,MAAOF,EAAY4B,EAAc/B,EAAS,EAAE,EAErG,OADY,MAAM,KAAK,aAAaI,EAAK,MAAOC,CAAa,GAClD,KAAI,CACjB,CAQA,MAAM,kBAAkBvB,EAAaQ,EAA4B,CAAA,EAAE,CACjE,KAAK,UAAUR,CAAG,EAClB,KAAK,KAAK,OAAQ,kBAAkBA,CAAG,EAAE,EACzC,GAAM,CAAE,aAAAiD,EAAc,mBAAAC,CAAkB,EAAK,KAAK,iBAAiB1C,CAAI,EACjEU,EAAU,CACd,CAACmC,CAAmB,EAAGC,EACvB,CAACnC,CAAyB,EAAGC,EAC7B,GAAG8B,GAEC7B,EAAavC,EAAkBkB,CAAG,EAClC,CAAE,IAAAsB,EAAK,QAASC,CAAa,EAAK,MAAM,KAAK,MAAM,MAAOF,EAAY4B,EAAc/B,EAAS,EAAE,EACrG,GAAI,CACF,IAAMQ,EAAM,MAAM,KAAK,aAAaJ,EAAK,MAAOC,CAAa,EAC7D,GAAI,CAACG,EAAI,GACP,MAAM,IAAI,MAAM,iCAAiCA,EAAI,MAAM,EAAE,EAG/D,IAAMiC,EAAOjC,EAAI,QAAQ,IAAI,MAAM,EACnC,GAAI,CAACiC,EACH,MAAM,IAAI,MAAM,oCAAoC,EAEtD,IAAME,EAAO,MAAMnC,EAAI,KAAI,EAC3B,MAAO,CAAE,KAAAiC,EAAM,KAAAE,CAAI,CACrB,OAASlC,EAAO,CACd,WAAK,KAAK,QAAS,wBAAwB3B,CAAG,eAAe2B,CAAK,EAAE,EAC9DA,CACR,CACF,CAQA,MAAM,QAAQ3B,EAAaQ,EAA4B,CAAA,EAAE,CACvD,KAAK,UAAUR,CAAG,EAClB,KAAK,KAAK,OAAQ,uBAAuBA,CAAG,EAAE,EAC9C,GAAM,CAAE,aAAAiD,EAAc,mBAAAC,CAAkB,EAAK,KAAK,iBAAiB1C,CAAI,EACjEU,EAAU,CACd,CAACmC,CAAmB,EAAGC,EACvB,CAACnC,CAAyB,EAAGC,EAC7B,GAAG8B,GAEC7B,EAAavC,EAAkBkB,CAAG,EAClC,CAAE,IAAAsB,EAAK,QAASC,CAAa,EAAK,MAAM,KAAK,MAAM,OAAQF,EAAY4B,EAAc/B,EAAS,EAAE,EAEhGQ,EAAM,MAAM,KAAK,aAAaJ,EAAK,OAAQC,CAAa,EAE9D,GADA,KAAK,KAAK,OAAQ,oBAAqBG,EAAI,OAAQA,EAAI,UAAW,EAAE,EAChE,CAACA,EAAI,IAAMA,EAAI,SAAW,IAE5B,OAAO,KAGT,IAAMiC,EAAOjC,EAAI,QAAQ,IAAI,MAAM,EACnC,GAAI,CAACiC,EACH,MAAM,IAAI,MAAM,oCAAoC,EAEtD,OAAOA,CACT,CAWA,MAAM,YACJ3D,EACAmE,EAAqB,GACrBC,EAAoB,EACpBC,EAAkB,KAAK,sBACvB7D,EAA4B,CAAA,EAAE,CAE9B,KAAK,UAAUR,CAAG,EAElB,GAAM,CAAE,aAAAiD,EAAc,mBAAAC,CAAkB,EAAK,KAAK,iBAAiB1C,CAAI,EACjEU,EAAU,CACd,CAACmC,CAAmB,EAAGC,EACvB,CAACnC,CAAyB,EAAGC,EAC7B,GAAG8B,GAEC7B,EAAavC,EAAkBkB,CAAG,EAClC,CAAE,IAAAsB,EAAK,QAASC,CAAa,EAAK,MAAM,KAAK,MAAM,MAAOF,EAAY4B,EAAc/B,EAAS,EAAE,EAC/FqC,EAAe,GAAGjC,CAAG,IAAI,IAAI,gBAAgB2B,CAAY,CAAC,GAEhE,OAAO,KAAK,aAAaM,EAAc,MAAOhC,CAAa,CAC7D,CASA,MAAM,IAAIvB,EAAa6D,EAAqB,CAE1C,GADA,KAAK,UAAU7D,CAAG,EACd,EAAE6D,aAAgB,QAAU,OAAOA,GAAS,UAC9C,WAAK,KAAK,QAASS,CAA0B,EACvC,IAAI,UAAUA,CAA0B,EAGhD,KAAK,KAAK,OAAQ,oBAAoBtE,CAAG,EAAE,EAC3C,IAAMwB,EAAgB,OAAOqC,GAAS,SAAW,OAAO,WAAWA,CAAI,EAAIA,EAAK,OAC1E3C,EAAU,CACd,CAACO,CAAqB,EAAGD,GAErBH,EAAavC,EAAkBkB,CAAG,EAClC,CAAE,IAAAsB,EAAK,QAASC,CAAa,EAAK,MAAM,KAAK,MAAM,MAAOF,EAAY,CAAA,EAAIH,EAAS2C,CAAI,EAE7F,OADY,MAAM,KAAK,aAAavC,EAAK,MAAOC,EAAesC,CAAI,CAErE,CAUA,MAAM,qBAAqB7D,EAAauE,EAAmBC,EAA2B,CAEpF,GADA,KAAK,UAAUxE,CAAG,EACd,OAAOuE,GAAa,SACtB,WAAK,KAAK,QAAS,GAAGxE,CAAY,2BAA2B,EACvD,IAAI,UAAU,GAAGA,CAAY,2BAA2B,EAEhE,KAAK,KAAK,OAAQ,0CAA0CC,CAAG,EAAE,EACjE,IAAM8B,EAAQ,CAAE,QAAS,EAAE,EACrBZ,EAAU,CACd,CAACmC,CAAmB,EAAGkB,EACvB,CAACpD,CAAyB,EAAGC,GAGzBC,EAAavC,EAAkBkB,CAAG,EAClC,CAAE,IAAAsB,EAAK,QAASC,CAAa,EAAK,MAAM,KAAK,MAAM,OAAQF,EAAYS,EAAOZ,EAAS,EAAE,EACzFqC,EAAe,GAAGjC,CAAG,IAAI,IAAI,gBAAgBQ,CAAK,CAAC,GAGnD0B,EAAe,MADT,MAAM,KAAK,aAAaD,EAAc,OAAQhC,CAAa,GACxC,KAAI,EAC7BkD,EAAiBX,EAAUN,CAAY,EAE7C,GACE,OAAOiB,GAAmB,UAC1BA,IAAmB,MACnB,UAAWA,GACX,OAAOA,EAAe,OAAU,UAChCA,EAAe,QAAU,MACzB,YAAaA,EAAe,MAC5B,CACA,IAAM7C,EAAe,OAAO6C,EAAe,MAAM,OAAO,EACxD,WAAK,KAAK,QAAS,GAAG1E,CAAY,qCAAqC6B,CAAY,EAAE,EAC/E,IAAI,MAAM,GAAG7B,CAAY,qCAAqC6B,CAAY,EAAE,CACpF,CAEA,GAAI,OAAO6C,GAAmB,UAAYA,IAAmB,KAAM,CACjE,GAAI,CAACA,EAAe,+BAAiC,CAACA,EAAe,8BAA8B,SACjG,WAAK,KAAK,QAAS,GAAG1E,CAAY,4DAA4D,EACxF,IAAI,MAAM,GAAGA,CAAY,kEAAkE,EAGnG,OAAO0E,EAAe,8BAA8B,QACtD,KACE,YAAK,KAAK,QAAS,GAAG1E,CAAY,+DAA+D,EAC3F,IAAI,MAAM,GAAGA,CAAY,+DAA+D,CAElG,CAYA,MAAM,WACJC,EACA6D,EACAa,EACAC,EACAnE,EAAe,CAAA,EAAE,CAEjB,KAAK,0BAA0BR,EAAK6D,EAAMa,EAAUC,EAAYnE,CAAI,EACpE,IAAMsB,EAAQ,CAAE,SAAA4C,EAAU,WAAAC,EAAY,GAAGnE,CAAI,EACvCU,EAAU,CACd,CAACO,CAAqB,EAAGoC,EAAK,QAG1BxC,EAAavC,EAAkBkB,CAAG,EAClC,CAAE,IAAAsB,EAAK,QAASC,CAAa,EAAK,MAAM,KAAK,MAAM,MAAOF,EAAYS,EAAOZ,EAAS2C,CAAI,EAC1FN,EAAe,GAAGjC,CAAG,IAAI,IAAI,gBAAgBQ,CAAK,CAAC,GAGnD8C,GADM,MAAM,KAAK,aAAarB,EAAc,MAAOhC,EAAesC,CAAI,GAC3D,QAAQ,IAAI,MAAM,GAAK,GACxC,MAAO,CAAE,WAAAc,EAAY,KAAAC,CAAI,CAC3B,CAEQ,0BACN5E,EACA6D,EACAa,EACAC,EACAnE,EAAY,CAGZ,GADA,KAAK,UAAUR,CAAG,EACd,EAAE6D,aAAgB,QAAU,OAAOA,GAAS,UAC9C,WAAK,KAAK,QAASS,CAA0B,EACvC,IAAI,UAAUA,CAA0B,EAEhD,GAAI,OAAOI,GAAa,UAAYA,EAAS,KAAI,EAAG,SAAW,EAC7D,WAAK,KAAK,QAASG,CAAwB,EACrC,IAAI,UAAUA,CAAwB,EAE9C,GAAI,CAAC,OAAO,UAAUF,CAAU,GAAKA,GAAc,EACjD,WAAK,KAAK,QAAS,GAAG5E,CAAY,uCAAuC,EACnE,IAAI,UAAU,GAAGA,CAAY,uCAAuC,EAE5E,KAAK,WAAWS,CAAI,CACtB,CAWA,MAAM,wBACJR,EACA0E,EACAI,EAAwB,CAGxB,GADA,KAAK,UAAU9E,CAAG,EACd,OAAO0E,GAAa,UAAYA,EAAS,KAAI,EAAG,SAAW,EAC7D,WAAK,KAAK,QAASG,CAAwB,EACrC,IAAI,UAAUA,CAAwB,EAE9C,GAAI,CAAC,MAAM,QAAQC,CAAK,GAAKA,EAAM,SAAW,EAC5C,WAAK,KAAK,QAASC,CAAoB,EACjC,IAAI,UAAUA,CAAoB,EAE1C,GAAI,CAACD,EAAM,MAAME,GAAQ,OAAOA,EAAK,YAAe,UAAY,OAAOA,EAAK,MAAS,QAAQ,EAC3F,WAAK,KAAK,QAASC,CAAkB,EAC/B,IAAI,UAAUA,CAAkB,EAExC,KAAK,KAAK,OAAQ,6BAA6BP,CAAQ,eAAe1E,CAAG,EAAE,EAC3E,IAAM8B,EAAQ,CAAE,SAAA4C,CAAQ,EAClBQ,EAAU,KAAK,iCAAiCJ,CAAK,EACrD5D,EAAU,CACd,CAACmC,CAAmB,EAAG8B,EACvB,CAAC1D,CAAqB,EAAG,OAAO,WAAWyD,CAAO,EAAE,SAAQ,EAC5D,CAAC/D,CAAyB,EAAG,MAAMc,EAAMiD,CAAO,GAE5C7D,EAAavC,EAAkBkB,CAAG,EAClC,CAAE,IAAAsB,EAAK,QAASC,CAAa,EAAK,MAAM,KAAK,MAAM,OAAQF,EAAYS,EAAOZ,EAASgE,CAAO,EAC9F3B,EAAe,GAAGjC,CAAG,IAAI,IAAI,gBAAgBQ,CAAK,CAAC,GAGnD0B,EAAe,MADT,MAAM,KAAK,aAAaD,EAAc,OAAQhC,EAAe2D,CAAO,GACjD,KAAI,EAC7BT,EAAiBX,EAAUN,CAAY,EAE7C,GACE,OAAOiB,GAAmB,UAC1BA,IAAmB,MACnB,UAAWA,GACX,OAAOA,EAAe,OAAU,UAChCA,EAAe,QAAU,MACzB,YAAaA,EAAe,MAC5B,CACA,IAAM7C,EAAe,OAAO6C,EAAe,MAAM,OAAO,EACxD,WAAK,KAAK,QAAS,GAAG1E,CAAY,qCAAqC6B,CAAY,EAAE,EAC/E,IAAI,MAAM,GAAG7B,CAAY,qCAAqC6B,CAAY,EAAE,CACpF,CAEA,OAAO6C,EAAe,6BACxB,CASA,MAAM,qBAAqBzE,EAAa0E,EAAgB,CAGtD,GADA,KAAK,UAAU1E,CAAG,EACd,OAAO0E,GAAa,UAAYA,EAAS,KAAI,EAAG,SAAW,EAC7D,WAAK,KAAK,QAASG,CAAwB,EACrC,IAAI,UAAUA,CAAwB,EAG9C,KAAK,KAAK,OAAQ,6BAA6BH,CAAQ,eAAe1E,CAAG,EAAE,EAG3E,IAAM8B,EAAQ,CAAE,SAAA4C,CAAQ,EAClBxD,EAAU,CACd,CAACmC,CAAmB,EAAG8B,EACvB,CAAChE,CAAyB,EAAGC,GAG/B,GAAI,CAEF,IAAMC,EAAavC,EAAkBkB,CAAG,EAClC,CAAE,IAAAsB,EAAK,QAASC,CAAa,EAAK,MAAM,KAAK,MAAM,SAAUF,EAAYS,EAAOZ,EAAS,EAAE,EAC3FqC,EAAe,GAAGjC,CAAG,IAAI,IAAI,gBAAgBQ,CAAK,CAAC,GAEnDJ,EAAM,MAAM,KAAK,aAAa6B,EAAc,SAAUhC,CAAa,EAGzE,GAAIG,EAAI,GAAI,CACV,IAAM8B,EAAe,MAAM9B,EAAI,KAAI,EAC7B+C,EAAiBX,EAAUN,CAAY,EAE7C,GACE,OAAOiB,GAAmB,UAC1BA,IAAmB,MACnB,UAAWA,GACX,OAAOA,EAAe,OAAU,UAChCA,EAAe,QAAU,MACzB,YAAaA,EAAe,MAC5B,CACA,IAAM7C,EAAe,OAAO6C,EAAe,MAAM,OAAO,EACxD,WAAK,KAAK,QAAS,GAAG1E,CAAY,qCAAqC6B,CAAY,EAAE,EAC/E,IAAI,MAAM,GAAG7B,CAAY,qCAAqC6B,CAAY,EAAE,CACpF,CAEA,MAAO,CACL,OAAQ,UACR,IAAA5B,EACA,SAAA0E,EACA,SAAUD,EAEd,KACE,YAAK,KAAK,QAAS,GAAG1E,CAAY,oCAAoC2B,EAAI,MAAM,EAAE,EAC5E,IAAI,MAAM,GAAG3B,CAAY,oCAAoC2B,EAAI,MAAM,EAAE,CAEnF,OAASC,EAAgB,CACvB,IAAMC,EAAeD,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,EAC1E,WAAK,KAAK,QAAS,GAAG5B,CAAY,4CAA4CC,CAAG,KAAK4B,CAAY,EAAE,EAC9F,IAAI,MAAM,GAAG7B,CAAY,4CAA4CC,CAAG,KAAK4B,CAAY,EAAE,CACnG,CACF,CAEQ,iCAAiCkD,EAAwB,CAC/D,MAAO;;UAEDA,EACC,IACCE,GAAQ;;0BAEMA,EAAK,UAAU;oBACrBA,EAAK,IAAI;;SAEpB,EAEE,KAAK,EAAE,CAAC;;KAGjB,CAOA,MAAM,OAAOhF,EAAW,CACtB,KAAK,UAAUA,CAAG,EAClB,KAAK,KAAK,OAAQ,mBAAmBA,CAAG,EAAE,EAC1C,IAAMkB,EAAU,CACd,CAACmC,CAAmB,EAAGC,EACvB,CAACnC,CAAyB,EAAGC,GAEzBC,EAAavC,EAAkBkB,CAAG,EAClC,CAAE,IAAAsB,EAAK,QAASC,CAAa,EAAK,MAAM,KAAK,MAAM,SAAUF,EAAY,CAAA,EAAIH,EAAS,EAAE,EACxFQ,EAAM,MAAM,KAAK,aAAaJ,EAAK,SAAUC,CAAa,EAChE,OAAIG,EAAI,SAAW,KAAOA,EAAI,SAAW,GAI3C,CAEA,MAAM,aACJJ,EACAxB,EACAoB,EACAa,EAAsB,CAEtB,KAAK,KAAK,OAAQ,WAAWjC,CAAM,eAAewB,CAAG,cAAc,KAAK,UAAUJ,CAAO,CAAC,EAAE,EAC5F,IAAMQ,EAAM,MAAM,MAAMJ,EAAK,CAC3B,OAAAxB,EACA,QAAAoB,EACA,KAAAa,EACA,OAAQ,KAAK,sBAAwB,OAAY,YAAY,QAAQ,KAAK,mBAAmB,EAAI,OAClG,EAED,OAAKL,EAAI,IACP,MAAM,KAAK,qBAAqBA,CAAG,EAG9BA,CACT,CAEA,MAAM,qBAAqBA,EAAa,CACtC,IAAM0D,EAAY,MAAM1D,EAAI,KAAI,EAC1B2D,EAAY3D,EAAI,QAAQ,IAAI,kBAAkB,GAAK,UACnDE,EAAeF,EAAI,QAAQ,IAAI,qBAAqB,GAAKA,EAAI,WACnE,WAAK,KACH,QACA,GAAG3B,CAAY,8BAA8B2B,EAAI,MAAM,KAAK2D,CAAS,MAAMzD,CAAY,cAAcwD,CAAS,EAAE,EAE5G,IAAI,MACR,GAAGrF,CAAY,8BAA8B2B,EAAI,MAAM,KAAK2D,CAAS,MAAMzD,CAAY,eAAewD,CAAS,EAAE,CAErH,CAEA,2BAA2BE,EAAmB,CAC5C,OAAI,OAAO,KAAKA,CAAW,EAAE,OAAS,EAC7B,GAGF,OAAO,KAAKA,CAAW,EAC3B,KAAI,EACJ,IAAItF,GAAO,GAAG,mBAAmBA,CAAG,CAAC,IAAI,mBAAoBsF,EAAoCtF,CAAG,CAAC,CAAC,EAAE,EACxG,KAAK,GAAG,CACb,CACA,MAAM,iBAAiBuF,EAAiB,CACtC,IAAMC,EAAQ,MAAMxC,EAAM,OAAO,KAAK,eAAe,GAAIuC,CAAS,EAC5DE,EAAU,MAAMzC,EAAMwC,EAAO,KAAK,MAAM,EACxCE,EAAW,MAAM1C,EAAMyC,EAAS7C,CAAU,EAChD,OAAOI,EAAM0C,EAAU7C,CAAgB,CACzC,GAGIZ,EAAQ,MAAO0D,GAA6C,CAChE,IAAMC,EAAUpH,EAAY,QAAQ,EACpC,OAAAoH,EAAQ,OAAOD,CAAO,EACfC,EAAQ,OAAO,KAAK,CAC7B,EAEM5C,EAAQ,MAAOhD,EAAsB2F,EAAiBE,IAAqC,CAC/F,IAAMC,EAAUvH,EAAY,SAAUyB,CAAG,EACzC,OAAA8F,EAAQ,OAAOH,CAAO,EACfG,EAAQ,OAAOD,CAAQ,CAChC,EAEM/B,EAAaiC,GAAsC,CACvD,IAAMC,EAAetD,GACZA,EACJ,QAAQ,UAAW,GAAG,EACtB,QAAQ,UAAW,GAAG,EACtB,QAAQ,QAAS,GAAG,EACpB,QAAQ,QAAS,GAAG,EACpB,QAAQ,SAAU,GAAG,EAGpBuD,EAAO,CAAA,EACPC,EAAK,2DACPC,EAEJ,KAAQA,EAAQD,EAAG,KAAKH,CAAG,GAAI,CAC7B,GAAM,CAAC,CAAE3F,EAAQJ,EAAK0C,CAAK,EAAIyD,EACzBC,EAAUhG,EAAO,YAAW,EAAKJ,EACjCqG,EAAc3D,GAAS,KAAOoB,EAAUpB,CAAK,EAAI,GAEnD,OAAO2D,GAAgB,SACxBJ,EAAgCG,CAAO,EAAIJ,EAAYK,CAAW,EAC1D,MAAM,QAASJ,EAAgCG,CAAO,CAAC,EAC/DH,EAAgCG,CAAO,EAAE,KAAKC,CAAW,EAEzDJ,EAAgCG,CAAO,EACrCH,EAAgCG,CAAO,GAAK,KACzC,CAAEH,EAAgCG,CAAO,EAAGC,CAAW,EACvD5H,GAAY2H,CAAO,EACjB,CAACC,CAAW,EACZA,CAEZ,CAEA,OAAO,OAAO,KAAKJ,CAAI,EAAE,OAASA,EAAOD,EAAYD,CAAG,CAC1D,EAGA,IAAAO,GAAeC",
  "names": ["AWS_ALGORITHM", "AWS_REQUEST_TYPE", "S3_SERVICE", "LIST_TYPE", "UNSIGNED_PAYLOAD", "DEFAULT_STREAM_CONTENT_TYPE", "XML_CONTENT_TYPE", "JSON_CONTENT_TYPE", "SENSITIVE_KEYS_REDACTED", "HEADER_AMZ_CONTENT_SHA256", "HEADER_AMZ_DATE", "HEADER_HOST", "HEADER_AUTHORIZATION", "HEADER_CONTENT_TYPE", "HEADER_CONTENT_LENGTH", "HEADER_ETAG", "HEADER_LAST_MODIFIED", "ERROR_PREFIX", "ERROR_ACCESS_KEY_REQUIRED", "ERROR_SECRET_KEY_REQUIRED", "ERROR_ENDPOINT_REQUIRED", "ERROR_BUCKET_NAME_REQUIRED", "ERROR_KEY_REQUIRED", "ERROR_UPLOAD_ID_REQUIRED", "ERROR_PARTS_REQUIRED", "ERROR_INVALID_PART", "ERROR_DATA_BUFFER_REQUIRED", "ERROR_PREFIX_TYPE", "ERROR_MAX_KEYS_TYPE", "ERROR_DELIMITER_REQUIRED", "_createHmac", "_createHash", "expectArray", "encodeAsHex", "c", "uriEscape", "uriStr", "uriResourceEscape", "string", "S3", "accessKeyId", "secretAccessKey", "endpoint", "bucketName", "region", "maxRequestSizeInBytes", "requestAbortTimeout", "logger", "props", "ERROR_ACCESS_KEY_REQUIRED", "ERROR_SECRET_KEY_REQUIRED", "ERROR_ENDPOINT_REQUIRED", "ERROR_BUCKET_NAME_REQUIRED", "method", "ERROR_PREFIX", "key", "ERROR_KEY_REQUIRED", "delimiter", "ERROR_DELIMITER_REQUIRED", "prefix", "ERROR_PREFIX_TYPE", "maxKeys", "ERROR_MAX_KEYS_TYPE", "opts", "level", "message", "additionalData", "sanitize", "obj", "acc", "SENSITIVE_KEYS_REDACTED", "sanitizedData", "logEntry", "headers", "HEADER_AMZ_CONTENT_SHA256", "UNSIGNED_PAYLOAD", "encodedKey", "url", "signedHeaders", "contentLength", "HEADER_CONTENT_LENGTH", "res", "error", "errorMessage", "keyPath", "query", "body", "datetime", "_hash", "HEADER_AMZ_DATE", "HEADER_HOST", "canonicalHeaders", "canonicalRequest", "stringToSign", "signature", "authorizationHeader", "HEADER_AUTHORIZATION", "value", "credentialScope", "S3_SERVICE", "AWS_REQUEST_TYPE", "AWS_ALGORITHM", "signingKey", "_hmac", "filteredOpts", "conditionalHeaders", "ifHeaders", "LIST_TYPE", "HEADER_CONTENT_TYPE", "JSON_CONTENT_TYPE", "urlWithQuery", "responseBody", "lastModified", "HEADER_LAST_MODIFIED", "etag", "HEADER_ETAG", "data", "_parseXml", "output", "_a", "_b", "_c", "wholeFile", "rangeFrom", "rangeTo", "ERROR_DATA_BUFFER_REQUIRED", "fileType", "DEFAULT_STREAM_CONTENT_TYPE", "parsedResponse", "uploadId", "partNumber", "ETag", "ERROR_UPLOAD_ID_REQUIRED", "parts", "ERROR_PARTS_REQUIRED", "part", "ERROR_INVALID_PART", "xmlBody", "XML_CONTENT_TYPE", "errorBody", "errorCode", "queryParams", "dateStamp", "kDate", "kRegion", "kService", "content", "hashSum", "encoding", "hmacSum", "str", "unescapeXml", "json", "re", "match", "fullKey", "parsedValue", "lib_default", "S3"]
}
